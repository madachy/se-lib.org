{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Home \u00b6 Introduction \u00b6 Welcome to the Systems Engineering Library (se-lib) (previously called PyML). It provides capabilities for integrated systems modeling, simulation, analysis and diagrams covering SysML, discrete event and continuous system dynamics simulation, reliability analysis, causal analysis, project management, and more using simple Python code as the glue. The open source Python scientific computing ecosystem enables advanced analysis with powerful libraries and language features. se-lib is built with Graphviz, Matplotlib, NetworkX, NumPy, PySD, SciPy, and SimPy. Quick Start \u00b6 Try se-lib instantly with these Colab notebooks in a browser, no installation required. se-lib examples System dynamics modeling user's guide and examples Discrete event modeling user's guide and examples se-lib also runs on standalone web pages for rapid experimentation and instruction. SysML Diagram Scratchpad Discrete Event Modeling Demonstrations se-lib playground Installation \u00b6 pip install se-lib For more detailed installation instructions, see the Installation page. Current Features \u00b6 The current features of se-lib can be found under Function Reference . Key capabilities include: SysML Diagrams: Context diagrams, use case diagrams, activity diagrams, requirements diagrams, block diagrams, and more Discrete Event Simulation: Model and simulate discrete event systems with queues, servers, and resources System Dynamics: Continuous simulation and causal loop diagrams Reliability Analysis: Fault tree analysis and reliability block diagrams Project Management: PERT charts, Gantt charts, critical path analysis, and design structure matrices Network Analysis: Using NetworkX for complex system relationships Presentations \u00b6 The following was presented at the 2022 INCOSE San Diego Mini-Conference: Introduction to PyML Acknowledgments \u00b6 se-lib research and development is supported by these sponsors: Boehm Center for Systems and Software Engineering Naval Postgraduate School Foundation Marine Corps Air Station (MCAS) Miramar Feedback \u00b6 We value your feedback. Tell us how we can make se-lib, its documentation and this website more useful. Please send comments, suggestions and interest in supporting the development to info@se-lib.org . \u00a9 Copyright 2025, se-lib Development Team. Last updated on Dec 12, 2025.","title":"Home"},{"location":"#home","text":"","title":"Home"},{"location":"#introduction","text":"Welcome to the Systems Engineering Library (se-lib) (previously called PyML). It provides capabilities for integrated systems modeling, simulation, analysis and diagrams covering SysML, discrete event and continuous system dynamics simulation, reliability analysis, causal analysis, project management, and more using simple Python code as the glue. The open source Python scientific computing ecosystem enables advanced analysis with powerful libraries and language features. se-lib is built with Graphviz, Matplotlib, NetworkX, NumPy, PySD, SciPy, and SimPy.","title":"Introduction"},{"location":"#quick-start","text":"Try se-lib instantly with these Colab notebooks in a browser, no installation required. se-lib examples System dynamics modeling user's guide and examples Discrete event modeling user's guide and examples se-lib also runs on standalone web pages for rapid experimentation and instruction. SysML Diagram Scratchpad Discrete Event Modeling Demonstrations se-lib playground","title":"Quick Start"},{"location":"#installation","text":"pip install se-lib For more detailed installation instructions, see the Installation page.","title":"Installation"},{"location":"#current-features","text":"The current features of se-lib can be found under Function Reference . Key capabilities include: SysML Diagrams: Context diagrams, use case diagrams, activity diagrams, requirements diagrams, block diagrams, and more Discrete Event Simulation: Model and simulate discrete event systems with queues, servers, and resources System Dynamics: Continuous simulation and causal loop diagrams Reliability Analysis: Fault tree analysis and reliability block diagrams Project Management: PERT charts, Gantt charts, critical path analysis, and design structure matrices Network Analysis: Using NetworkX for complex system relationships","title":"Current Features"},{"location":"#presentations","text":"The following was presented at the 2022 INCOSE San Diego Mini-Conference: Introduction to PyML","title":"Presentations"},{"location":"#acknowledgments","text":"se-lib research and development is supported by these sponsors: Boehm Center for Systems and Software Engineering Naval Postgraduate School Foundation Marine Corps Air Station (MCAS) Miramar","title":"Acknowledgments"},{"location":"#feedback","text":"We value your feedback. Tell us how we can make se-lib, its documentation and this website more useful. Please send comments, suggestions and interest in supporting the development to info@se-lib.org . \u00a9 Copyright 2025, se-lib Development Team. Last updated on Dec 12, 2025.","title":"Feedback"},{"location":"examples/","text":"Examples \u00b6 Open these examples in a Google Colaboratory Notebook. Simulations \u00b6 Simulation models in se-lib are defined as logical nodes in a system and their connections. Function calls enable system dynamics models to be expressed as stocks, flows and auxiliary variables connected in feedback loops. Discrete event models are defined as connected path nodes for entity generation, delays, queues/servers, and termination nodes. Utilities are provided for output visualization and statistical analysis. Hybrid models and can be developed with relationships between continuous and discrete event parameters. The following are available online: * se-lib system dynamics examples on Google Colab * Discrete event modeling and simulation on se-lib playground See the following manuals for further details. * System Dynamics Modeling with se-lib User's Guide v. 1.0 System Dynamics Model \u00b6 # Battle Simulator using Lanchester's Law for Aimed Fire with Reinforcements init_sd_model ( start = 0 , stop = 2 , dt = .05 ) step_size = 600 add_stock ( \"blue_troops\" , 1000 , inflows = [ \"blue_reinforcements\" ], outflows = [ \"blue_attrition\" ]) add_flow ( \"blue_attrition\" , \"red_troops*red_lethality\" ) add_flow ( \"blue_reinforcements\" , \"step(200, .7)-step(200, 1.2)\" ) add_auxiliary ( \"blue_lethality\" , \"random.uniform(.7, .9)\" ) add_stock ( \"red_troops\" , 800 , inflows = [ \"red_reinforcements\" ], outflows = [ \"red_attrition\" ]) add_flow ( \"red_attrition\" , \"blue_troops*blue_lethality\" ) add_flow ( \"red_reinforcements\" , f \"step( { step_size } , .3)-step( { step_size } , .7)\" ) add_auxiliary ( \"red_lethality\" , \"random.uniform(.8, 1.0)\" ) run_model () save_graph ([ 'blue_troops' , 'red_troops' ], filename = \"battle_simulator_troop_levels\" ) save_graph ([ \"red_attrition\" , \"red_reinforcements\" , 'blue_attrition' , 'blue_reinforcements' ], filename = \"battle_simulator_flow_rates\" ) Discrete Event Model \u00b6 # electric car charging simulation init_de_model () add_source ( 'incoming_cars' , entity_name = \"Car\" , num_entities = 50 , connections = { 'charger' : .7 , 'impatient_cars' : .3 }, interarrival_time = 'np.random.exponential(5)' ) add_server ( name = 'charger' , connections = { 'payment' : 1 }, service_time = 'np.random.uniform(0, 16)' , capacity = 1 ) add_delay ( name = 'payment' , delay_time = 'np.random.uniform(1, 3)' , connections = { 'served_cars' : 1 },) add_terminate ( 'served_cars' ) add_terminate ( 'impatient_cars' ) draw_model_diagram () model_data , entity_data = run_model () plot_histogram ( model_data [ 'charger' ][ 'waiting_times' ], xlabel = \"Charger Waiting Time\" ) Analyses \u00b6 Quantitative Fault Tree \u00b6 # UUV computed fault tree given probabilities for basic events uuv_fault_tree = [ ( \"UUV Mission Data Loss\" , \"or\" , '' , [ \"Communication Loss\" , \"Power Down\" , \"All Sensors Fail\" ]), ( 'All Sensors Fail' , 'and' , '' , [ 'Low Resolution Sensor 1 Fails' , 'Low Resolution Sensor 2 Fails' , 'High Resolution Sensor 3 Fails' ]), ( 'Power Down' , 'and' , '' , [ \"Main Power Down\" , \"Backup Power Down\" ]), ( 'Communication Loss' , 'basic' , .003 ), ( 'Main Power Down' , 'basic' , .02 ), ( 'Backup Power Down' , 'basic' , .08 ), ( 'Low Resolution Sensor 1 Fails' , 'basic' , .001 ), ( 'Low Resolution Sensor 2 Fails' , 'basic' , .001 ), ( 'High Resolution Sensor 3 Fails' , 'basic' , .003 ), ] se . draw_fault_tree_diagram_quantitative ( uuv_fault_tree , filename = \"uuv_quantitative_fault_tree\" , format = \"svg\" ) Critical Path Analysis \u00b6 A critical path can be computed from a set of tasks with associated time durations and dependencies as below. # tasks, durations and dependencies tasks = [( 'A' , { 'Duration' : 3 }), ( 'B' , { 'Duration' : 5 }), ( 'C' , { 'Duration' : 2 }), ( 'D' , { 'Duration' : 3 }), ( 'E' , { 'Duration' : 5 })] task_dependencies = [( 'A' , 'C' ), ( 'B' , 'C' ), ( 'A' , 'D' ), ( 'C' , 'E' ), ( 'D' , 'E' )] # create diagram se . critical_path_diagram ( tasks , task_dependencies , filename = \"critical_path\" ) Diagrams \u00b6 These examples generate diagrams to be displayed from a Python console or Jupyter Notebook. After importing se-lib, model elements can be specified as simple lists. Element relationships are designated as lists of tuple pairs. The output filenames are optional and used here to generate the included SVG images. Use Case Model \u00b6 Actors and use cases are first specified in lists. The interactions between actors and use cases are identified by their tuple pairs and drawn accordingly on the diagram. import selib as se # system model system_name = \"Course Portal\" actors = [ 'Student' , 'Instructor' ] use_cases = [ 'Post Discussion' , 'Take Quiz' , 'Create Quiz' ] interactions = [( 'Student' , 'Post Discussion' ), ( 'Instructor' , 'Post Discussion' ), ( 'Student' , 'Take Quiz' ), ( 'Instructor' , 'Create Quiz' )] use_case_relationships = [] # create diagram se . use_case_diagram ( system_name , actors , use_cases , interactions , use_case_relationships , filename = system_name + 'use case diagram.pdf' ) ``` ! [ Course_Portal_use_case_diagram . svg ]( assets / Course_Portal_use_case_diagram . svg ) #### Sequence Model A sequence diagram can be constructed per the following . ``` python # system model system_name = \"Battle Simulator\" actors = [ 'Battle Planner' ] objects = [ 'main' ] actions = [ ( 'Battle Planner' , 'main' , 'run()' ), ( 'main' , 'Battle Planner' , 'request for side 1 name' ), ( 'Battle Planner' , 'main' , 'side 1 name' ), ( 'main' , 'Battle Planner' , 'request for side 2 name' ), ( 'Battle Planner' , 'main' , 'side 2 name' ), ( 'main' , 'Battle Planner' , 'request for side 1 starting level' ), ( 'Battle Planner' , 'main' , 'side 1 starting level' ), ( 'main' , 'Battle Planner' , 'request for side 1 lethality coefficient' ), ( 'Battle Planner' , 'main' , 'side 1 lethality coefficient' ), ( 'main' , 'Battle Planner' , 'request for side 2 starting level' ), ( 'Battle Planner' , 'main' , 'side 2 starting level' ), ( 'main' , 'Battle Planner' , 'request for side 2 lethality coefficient' ), ( 'Battle Planner' , 'main' , 'side 2 lethality coefficient' ), ( 'main' , 'Battle Planner' , 'time history of troops and victor' ), ] # create diagram se . sequence_diagram ( system_name , actors , objects , actions , filename = system_name + \"_sequence_diagram\" ) Context Model \u00b6 # system model system_name = \"Python Interpreter with PyML\" external_actors = [ \"User\" , \"OS\" , \"Graphviz\" ] # create context diagram se . context_diagram ( system_name , external_actors , filename = \"pyml_context_diagram_offline\" ) Requirements Model \u00b6 # Intelligence, Surveillance, & Reconnaissance Unmanned Underwater Vehicle (ISR UUV) un-numbered requirements requirements = [( \"ISR UUV\" , \"Performance\" ), ( \"Performance\" , ( \"The UUV shall be capable of completing a mission of 6 hours duration.\" , \"The UUV shall be capable of a top speed of 14 knots.\" , \"The UUV shall be capable of surviving in an open ocean environment to a depth of 1500 meters.\" , \"The UUV shall avoid detection.\" )), ( \"ISR UUV\" , \"Communication\" ), ( \"Communication\" , ( \"Mission parameters shall be uploadable to the UUV\" , \"The UUV shall receive remote commands\" , \"The UUV shall commence its mission when commanded\" , \"The UUV shall be capable of transmitting data in a host ship compatible format\" , \"The UUV shall indicate that it is ready for recovery\" )),] # draw requirements diagram as horizontal tree left -> right se . requirements_diagram ( requirements , rankdir = 'LR' , filename = \"uuv_requirements_tree\" ) Work Breakdown Structure \u00b6 # project work breakdown structure wbs_decompositions = [ ( 'Skateboard' , 'Hardware' ), ( 'Skateboard' , 'Software' ), ( 'Skateboard' , 'Integration and Test' ), ( 'Hardware' , 'Board' ), ( 'Hardware' , 'Wheels' ), ( 'Hardware' , 'Mounting' ), ( 'Software' , 'OS' ), ( 'Software' , 'GPS Driver' ), ( 'Software' , 'Route Tracking' ), ( 'Integration and Test' , 'Fixed Platform' ), ( 'Integration and Test' , 'Street Testing' )] # create diagram se . wbs_diagram ( wbs_decompositions , filename = \"skateboard_wbs\" ) Design Structure Matrix \u00b6 tasks = [ 'Make Board' , 'Acquire Wheels' , 'Assemble' , 'Test' ] task_dependencies = [( 'Make Board' , 'Assemble' ), ( 'Acquire Wheels' , 'Assemble' ), ( 'Assemble' , 'Test' ), ( 'Test' , 'Assemble' )] se . design_structure_matrix ( tasks , task_dependencies , filename = \"skateboard_task_dsm_with_feedback\" ) dsm dsm Make Board Acquire Wheels Assemble Test Make Board Acquire Wheels Assemble X X X Test X Read Fault Tree from Excel \u00b6 Portion of example Excel file aav_fault_tree.xlsx : # read fault tree from Excel file into list of nodes fault_tree_list = se . read_fault_tree_excel ( 'aav_fault_tree.xlsx' ) # create fault tree diagram se . fault_tree_diagram ( fault_tree_list ) Causal Diagram \u00b6 # causal relationships relationships = [( 'Available personnel' , \"Workforce gap\" , \"-\" ), ( 'Required personnel' , \"Workforce gap\" , \"+\" ), ( \"Workforce gap\" , \"Hiring rate\" , \"+\" ), ( \"Hiring rate\" , \"Available personnel\" , \"+\" ), ] # draw diagram se . causal_diagram ( relationships )","title":"Examples"},{"location":"examples/#examples","text":"Open these examples in a Google Colaboratory Notebook.","title":"Examples"},{"location":"examples/#simulations","text":"Simulation models in se-lib are defined as logical nodes in a system and their connections. Function calls enable system dynamics models to be expressed as stocks, flows and auxiliary variables connected in feedback loops. Discrete event models are defined as connected path nodes for entity generation, delays, queues/servers, and termination nodes. Utilities are provided for output visualization and statistical analysis. Hybrid models and can be developed with relationships between continuous and discrete event parameters. The following are available online: * se-lib system dynamics examples on Google Colab * Discrete event modeling and simulation on se-lib playground See the following manuals for further details. * System Dynamics Modeling with se-lib User's Guide v. 1.0","title":"Simulations"},{"location":"examples/#system-dynamics-model","text":"# Battle Simulator using Lanchester's Law for Aimed Fire with Reinforcements init_sd_model ( start = 0 , stop = 2 , dt = .05 ) step_size = 600 add_stock ( \"blue_troops\" , 1000 , inflows = [ \"blue_reinforcements\" ], outflows = [ \"blue_attrition\" ]) add_flow ( \"blue_attrition\" , \"red_troops*red_lethality\" ) add_flow ( \"blue_reinforcements\" , \"step(200, .7)-step(200, 1.2)\" ) add_auxiliary ( \"blue_lethality\" , \"random.uniform(.7, .9)\" ) add_stock ( \"red_troops\" , 800 , inflows = [ \"red_reinforcements\" ], outflows = [ \"red_attrition\" ]) add_flow ( \"red_attrition\" , \"blue_troops*blue_lethality\" ) add_flow ( \"red_reinforcements\" , f \"step( { step_size } , .3)-step( { step_size } , .7)\" ) add_auxiliary ( \"red_lethality\" , \"random.uniform(.8, 1.0)\" ) run_model () save_graph ([ 'blue_troops' , 'red_troops' ], filename = \"battle_simulator_troop_levels\" ) save_graph ([ \"red_attrition\" , \"red_reinforcements\" , 'blue_attrition' , 'blue_reinforcements' ], filename = \"battle_simulator_flow_rates\" )","title":"System Dynamics Model"},{"location":"examples/#discrete-event-model","text":"# electric car charging simulation init_de_model () add_source ( 'incoming_cars' , entity_name = \"Car\" , num_entities = 50 , connections = { 'charger' : .7 , 'impatient_cars' : .3 }, interarrival_time = 'np.random.exponential(5)' ) add_server ( name = 'charger' , connections = { 'payment' : 1 }, service_time = 'np.random.uniform(0, 16)' , capacity = 1 ) add_delay ( name = 'payment' , delay_time = 'np.random.uniform(1, 3)' , connections = { 'served_cars' : 1 },) add_terminate ( 'served_cars' ) add_terminate ( 'impatient_cars' ) draw_model_diagram () model_data , entity_data = run_model () plot_histogram ( model_data [ 'charger' ][ 'waiting_times' ], xlabel = \"Charger Waiting Time\" )","title":"Discrete Event Model"},{"location":"examples/#analyses","text":"","title":"Analyses"},{"location":"examples/#quantitative-fault-tree","text":"# UUV computed fault tree given probabilities for basic events uuv_fault_tree = [ ( \"UUV Mission Data Loss\" , \"or\" , '' , [ \"Communication Loss\" , \"Power Down\" , \"All Sensors Fail\" ]), ( 'All Sensors Fail' , 'and' , '' , [ 'Low Resolution Sensor 1 Fails' , 'Low Resolution Sensor 2 Fails' , 'High Resolution Sensor 3 Fails' ]), ( 'Power Down' , 'and' , '' , [ \"Main Power Down\" , \"Backup Power Down\" ]), ( 'Communication Loss' , 'basic' , .003 ), ( 'Main Power Down' , 'basic' , .02 ), ( 'Backup Power Down' , 'basic' , .08 ), ( 'Low Resolution Sensor 1 Fails' , 'basic' , .001 ), ( 'Low Resolution Sensor 2 Fails' , 'basic' , .001 ), ( 'High Resolution Sensor 3 Fails' , 'basic' , .003 ), ] se . draw_fault_tree_diagram_quantitative ( uuv_fault_tree , filename = \"uuv_quantitative_fault_tree\" , format = \"svg\" )","title":"Quantitative Fault Tree"},{"location":"examples/#critical-path-analysis","text":"A critical path can be computed from a set of tasks with associated time durations and dependencies as below. # tasks, durations and dependencies tasks = [( 'A' , { 'Duration' : 3 }), ( 'B' , { 'Duration' : 5 }), ( 'C' , { 'Duration' : 2 }), ( 'D' , { 'Duration' : 3 }), ( 'E' , { 'Duration' : 5 })] task_dependencies = [( 'A' , 'C' ), ( 'B' , 'C' ), ( 'A' , 'D' ), ( 'C' , 'E' ), ( 'D' , 'E' )] # create diagram se . critical_path_diagram ( tasks , task_dependencies , filename = \"critical_path\" )","title":"Critical Path Analysis"},{"location":"examples/#diagrams","text":"These examples generate diagrams to be displayed from a Python console or Jupyter Notebook. After importing se-lib, model elements can be specified as simple lists. Element relationships are designated as lists of tuple pairs. The output filenames are optional and used here to generate the included SVG images.","title":"Diagrams"},{"location":"examples/#use-case-model","text":"Actors and use cases are first specified in lists. The interactions between actors and use cases are identified by their tuple pairs and drawn accordingly on the diagram. import selib as se # system model system_name = \"Course Portal\" actors = [ 'Student' , 'Instructor' ] use_cases = [ 'Post Discussion' , 'Take Quiz' , 'Create Quiz' ] interactions = [( 'Student' , 'Post Discussion' ), ( 'Instructor' , 'Post Discussion' ), ( 'Student' , 'Take Quiz' ), ( 'Instructor' , 'Create Quiz' )] use_case_relationships = [] # create diagram se . use_case_diagram ( system_name , actors , use_cases , interactions , use_case_relationships , filename = system_name + 'use case diagram.pdf' ) ``` ! [ Course_Portal_use_case_diagram . svg ]( assets / Course_Portal_use_case_diagram . svg ) #### Sequence Model A sequence diagram can be constructed per the following . ``` python # system model system_name = \"Battle Simulator\" actors = [ 'Battle Planner' ] objects = [ 'main' ] actions = [ ( 'Battle Planner' , 'main' , 'run()' ), ( 'main' , 'Battle Planner' , 'request for side 1 name' ), ( 'Battle Planner' , 'main' , 'side 1 name' ), ( 'main' , 'Battle Planner' , 'request for side 2 name' ), ( 'Battle Planner' , 'main' , 'side 2 name' ), ( 'main' , 'Battle Planner' , 'request for side 1 starting level' ), ( 'Battle Planner' , 'main' , 'side 1 starting level' ), ( 'main' , 'Battle Planner' , 'request for side 1 lethality coefficient' ), ( 'Battle Planner' , 'main' , 'side 1 lethality coefficient' ), ( 'main' , 'Battle Planner' , 'request for side 2 starting level' ), ( 'Battle Planner' , 'main' , 'side 2 starting level' ), ( 'main' , 'Battle Planner' , 'request for side 2 lethality coefficient' ), ( 'Battle Planner' , 'main' , 'side 2 lethality coefficient' ), ( 'main' , 'Battle Planner' , 'time history of troops and victor' ), ] # create diagram se . sequence_diagram ( system_name , actors , objects , actions , filename = system_name + \"_sequence_diagram\" )","title":"Use Case Model"},{"location":"examples/#context-model","text":"# system model system_name = \"Python Interpreter with PyML\" external_actors = [ \"User\" , \"OS\" , \"Graphviz\" ] # create context diagram se . context_diagram ( system_name , external_actors , filename = \"pyml_context_diagram_offline\" )","title":"Context Model"},{"location":"examples/#requirements-model","text":"# Intelligence, Surveillance, & Reconnaissance Unmanned Underwater Vehicle (ISR UUV) un-numbered requirements requirements = [( \"ISR UUV\" , \"Performance\" ), ( \"Performance\" , ( \"The UUV shall be capable of completing a mission of 6 hours duration.\" , \"The UUV shall be capable of a top speed of 14 knots.\" , \"The UUV shall be capable of surviving in an open ocean environment to a depth of 1500 meters.\" , \"The UUV shall avoid detection.\" )), ( \"ISR UUV\" , \"Communication\" ), ( \"Communication\" , ( \"Mission parameters shall be uploadable to the UUV\" , \"The UUV shall receive remote commands\" , \"The UUV shall commence its mission when commanded\" , \"The UUV shall be capable of transmitting data in a host ship compatible format\" , \"The UUV shall indicate that it is ready for recovery\" )),] # draw requirements diagram as horizontal tree left -> right se . requirements_diagram ( requirements , rankdir = 'LR' , filename = \"uuv_requirements_tree\" )","title":"Requirements Model"},{"location":"examples/#work-breakdown-structure","text":"# project work breakdown structure wbs_decompositions = [ ( 'Skateboard' , 'Hardware' ), ( 'Skateboard' , 'Software' ), ( 'Skateboard' , 'Integration and Test' ), ( 'Hardware' , 'Board' ), ( 'Hardware' , 'Wheels' ), ( 'Hardware' , 'Mounting' ), ( 'Software' , 'OS' ), ( 'Software' , 'GPS Driver' ), ( 'Software' , 'Route Tracking' ), ( 'Integration and Test' , 'Fixed Platform' ), ( 'Integration and Test' , 'Street Testing' )] # create diagram se . wbs_diagram ( wbs_decompositions , filename = \"skateboard_wbs\" )","title":"Work Breakdown Structure"},{"location":"examples/#design-structure-matrix","text":"tasks = [ 'Make Board' , 'Acquire Wheels' , 'Assemble' , 'Test' ] task_dependencies = [( 'Make Board' , 'Assemble' ), ( 'Acquire Wheels' , 'Assemble' ), ( 'Assemble' , 'Test' ), ( 'Test' , 'Assemble' )] se . design_structure_matrix ( tasks , task_dependencies , filename = \"skateboard_task_dsm_with_feedback\" ) dsm dsm Make Board Acquire Wheels Assemble Test Make Board Acquire Wheels Assemble X X X Test X","title":"Design Structure Matrix"},{"location":"examples/#read-fault-tree-from-excel","text":"Portion of example Excel file aav_fault_tree.xlsx : # read fault tree from Excel file into list of nodes fault_tree_list = se . read_fault_tree_excel ( 'aav_fault_tree.xlsx' ) # create fault tree diagram se . fault_tree_diagram ( fault_tree_list )","title":"Read Fault Tree from Excel"},{"location":"examples/#causal-diagram","text":"# causal relationships relationships = [( 'Available personnel' , \"Workforce gap\" , \"-\" ), ( 'Required personnel' , \"Workforce gap\" , \"+\" ), ( \"Workforce gap\" , \"Hiring rate\" , \"+\" ), ( \"Hiring rate\" , \"Available personnel\" , \"+\" ), ] # draw diagram se . causal_diagram ( relationships )","title":"Causal Diagram"},{"location":"function_reference/","text":"Function Reference \u00b6 To use se-lib, first import it before using any functions: import selib These function definitions follow the convention whereby required input parameters are shown first, then optional parameters are shown with an equal sign indicating the default values. A graph here is a generic set of nodes representing system elements connected by edges shown as non-directed or directed lines. Diagrams \u00b6 context_diagram \u00b6 selib. context_diagram ( system , external_systems , filename = None , format = 'svg' , engine = 'neato' ) \u00b6 Returns a context diagram. Parameters : system_name ( string ) \u2013 The name of the system to label the diagram. external_systems ( list of strings ) \u2013 Names of the external systems that interact with the system in a list. filename ( string , optional ) \u2013 A filename for the output not including a filename extension. The extension will specified by the format parameter. format ( string , optional ) \u2013 The file format of the graphic output. Note that bitmap formats (png, bmp, or jpeg) will not be as sharp as the default svg vector format and most particularly when magnified. Returns : g \u2013 Save the graph source code to file, and open the rendered result in its default viewing application. PyML calls the Graphviz API for this. Return type : graph object view critical_path_diagram \u00b6 selib. critical_path_diagram ( tasks , task_dependencies , filename = None , format = 'svg' ) \u00b6 Compute and draw the critical path between dependent tasks as the longest in duration from start to finish. Parameters : tasks ( list of tuples where each contains a task name and dictionary for duration time ) \u2013 A list of tuples where each one contains a task name and dictionary for its duration time (where keyword = \u201cDuration\u201d and value is a number). task_dependencies ( list of tuples ) \u2013 A list of tuples describing the dependency relationships between tasks. Each relationship is a tuple containing the predecessor task followed by its successor task. These must be the same named tasks in the task list input above. filename ( string , optional ) \u2013 A filename for the output not including a filename extension. The extension will specified by the format parameter. format ( string , optional ) \u2013 The file format of the graphic output. Note that bitmap formats (png, bmp, or jpeg) will not be as sharp as the default svg vector format and most particularly when magnified. Returns : g \u2013 The rendered graph for display. It will be automatically displayed in Jupyter Notebooks or IPython consoles. With other Python editors it can be displayed in the associated console by typing the returned graph name (e.g., call the function with an assignment such as critical_path = critical_path_diagram(...) and then type critical_path in the console). If a filename is optionally provided, the rendered graph will also be saved as a file in the specified format. PyML calls the Graphviz API for this. Return type : graph object view design_structure_matrix \u00b6 selib. design_structure_matrix ( elements , element_dependencies , filename = None , format = 'svg' ) \u00b6 Draw a design structure matrix of system elements and their dependencies. Matrix elements may represent tasks (process activities), system parameters or attributes. Parameters : elements ( list of strings ) \u2013 Names of the matrix elements as the row and column headings in a list. element_dependencies ( list of tuples ) \u2013 A list of tuples describing the relationships between elements. Each relationship is a tuple containing the relationship input element, output element and optionally a custom label (or other object) to mark the relationship in the form (\u201cinput element\u201d, \u201coutput element\u201d, \u201crelationship label\u201d). The default marking denoting a relationship is an uppercase \u2018X\u2019, therefore, the shortened tuple relationship (\u201cinput element\u201d, \u201coutput element\u201d) is equivalent to (\u201cinput element\u201d, \u201coutput element\u201d, \u201cX\u201d). A custom label can be specified as html code for styling of the font type, font color, cell color, etc. Images and unicode characters can be inserted this way, or other html markup for lists, tables, etc. filename ( string , optional ) \u2013 A filename for the output not including a filename extension. The extension will specified by the format parameter. format ( string , optional ) \u2013 The file format of the graphic output. Note that bitmap formats (png, bmp, or jpeg) will not be as sharp as the default svg vector format and most particularly when magnified. Returns : g \u2013 The rendered graph for display. It will be automatically displayed in Jupyter Notebooks or IPython consoles. With other Python editors it can be displayed in the associated console by typing the returned graph name (e.g., call the function with an assignment such as dsm = design_structure_matrix(...) and then type dsm in the console). If a filename is optionally provided, the rendered graph will also be saved as a file in the specified format. PyML calls the Graphviz API for this. Return type : graph object view fault_tree_diagram \u00b6 selib. fault_tree_diagram ( ft , filename = None , format = 'svg' ) \u00b6 Returns a fault tree diagram. Parameters : ft ( list of tuples ) \u2013 A list of the faults as a tree hierarchy. Each fault is defined in a tuple containing the fault name, type, and underlying faults (if any) in the form (\"fault name\", \"fault name\", list of fault branches) with the branches as a list in the form [\"branch 1 name\", \"branch 2 name\", ... \"branch n name\"] to identify the adjoining faults. All basic events will have a blank list [] since they are the bottom leaves in the tree. The top event must be in the first row, but all other events can be in any order. They may begrouped by their event paths or by hierarchical levels as convenient. Event types can be conditional \u201cand\u201ds, conditional \u201cor\u201ds, or basic events (leaves). The following spellings are recognized as valid designations for event types: And: \u201cAnd\u201d \u201cand\u201d \u201cAND\u201d Or: \u201cOr\u201d \u201cor\u201d \u201cOR\u201d Basic: \u201cBasic\u201d \u201cbasic\u201d \u201cBASIC\u201d filename ( string , optional ) \u2013 A filename for the output not including a filename extension. The extension will specified by the format parameter. format ( string , optional ) \u2013 The file format of the graphic output. Note that bitmap formats (png, bmp, or jpeg) will not be as sharp as the default svg vector format and most particularly when magnified. Returns : g \u2013 Save the graph source code to file, and open the rendered result in its default viewing application. PyML calls the Graphviz API for this. Return type : graph object view sequence_diagram \u00b6 selib. sequence_diagram ( system_name , actors , objects , actions , filename = None format = 'svg' ) \u00b6 Returns a sequence diagram. Parameters : system_name ( string ) \u2013 The name of the system to label the diagram. actors ( list of strings ) \u2013 Names of the outside actors that participate in the activity sequence in a list. objects ( list of strings ) \u2013 Names of the system objects that participate in the activity sequence in a list. actions ( list of tuples ) \u2013 A chronologically ordered list describing the sequence of actions to be drawn. Each action is a tuple containing the action source, target and action name (or data/control passed) in the form (\u201csource\u201d, \u201ctarget\u201d, \u201caction name\u201d) indicating a labeled horizontal arrow drawn between them. filename ( string , optional ) \u2013 A filename for the output not including a filename extension. The extension will specified by the format parameter. format ( string , optional ) \u2013 The file format of the graphic output. Note that bitmap formats (png, bmp, or jpeg) will not be as sharp as the default svg vector format and most particularly when magnified. Returns : g \u2013 Save the graph source code to file, and open the rendered result in its default viewing application. PyML calls the Graphviz API for this. Return type : graph object view ### use_case_diagram selib. use_case_diagram ( system_name , actors , use_cases , interactions , use_case_relationships , filename = None , format = 'svg' ) \u00b6 Draw a use case diagram. Parameters : system_name ( string ) \u2013 The name of the system to label the diagram. actors ( list of strings ) \u2013 Names of the outside actors that interact with the system in the use cases in a list. use_cases ( list of strings ) \u2013 Names of the use cases in a list. interactions ( list of tuples ) \u2013 A list of the interactions to be drawn between actors and use cases. Each interaction is a tuple containing an actor and use case in the form (\u201cactor name\u201d, \u201cuse case name\u201d) indicating an arrow drawn from the actor to the use case. Interactions are graph edges. use_case_relationships ( list of tuples , optional ) \u2013 A list of the relationships, or associations to be drawn between use cases. Each relationship is a tuple containing a use case pair and type relationship in the form (\u201cuse case 1\u201d, \u201cuse case 2\u201d, \u201crelationship\u201d) indicating an arrow drawn from the first to the second use case. Relationship types are \u201c<<include>>\u201d, \u201c<<extend>>\u201d and \u201cgeneralization\u201d. filename ( string , optional ) \u2013 A filename for the output not including a filename extension. The extension will specified by the format parameter. format ( string , optional ) \u2013 The file format of the graphic output. Note that bitmap formats (png, bmp, or jpeg) will not be as sharp as the default svg vector format and most particularly when magnified. Returns : g \u2013 Save the graph source code to file, and open the rendered result in its default viewing application. PyML calls the Graphviz API for this. Return type : graph object view wbs_diagram \u00b6 selib. wbs_diagram ( decompositions , filename = None , format = 'svg' , rankdir = 'TB' ) \u00b6 Draw a work breakdown structure as a tree hierarchy. Decompositions describe the parent-child relationships. Parameters : decompositions ( list of tuples ) \u2013 A list of tuples describing the work decomposition relationships. Each relationship is a tuple containing the parent element followed by the child element. filename ( string , optional ) \u2013 A filename for the output not including a filename extension. The extension will specified by the format parameter. format ( string , optional ) \u2013 The file format of the graphic output. Note that bitmap formats (png, bmp, or jpeg) will not be as sharp as the default svg vector format and most particularly when magnified. rankdir ( string , optional ) \u2013 The direction to display the tree from the parent node. The default rankdir='TB' denotes top to bottom for a vertical tree decomposition. It can diagrammed horizontally by providing rankdir=\u2019LR\u2019 to designate left to right. Returns : g \u2013 The rendered graph for display. It will be automatically displayed in Jupyter Notebooks or IPython consoles. With other Python editors it can be displayed in the associated console by typing the returned graph name (e.g., call the function with an assignment such as wbs = wbs_diagram(...) and then type wbs in the console). If a filename is optionally provided, the rendered graph will also be saved as a file in the specified format. PyML calls the Graphviz API for this. Return type : graph object view Analyses \u00b6 fault_tree_cutsets \u00b6 selib. fault_tree_cutsets ( fault_tree ) \u00b6 Returns a fault tree cutset. Parameters : ft ( list of tuples ) \u2013 A list of the faults as a tree hierarchy. Each fault is defined in a tuple containing the fault name, type, and underlying faults (if any) in the form (\"fault name\", \"fault name\", list of fault branches) with the branches as a list in the form [\"branch 1 name\", \"branch 2 name\", ... \"branch n name\"] to identify the adjoining faults. All basic events will have a blank list [] since they are the bottom leaves in the tree. The top event must be in the first row, but all other events can be in any order. They may begrouped by their event paths or by hierarchical levels as convenient. Event types can be conditional \u201cand\u201ds, conditional \u201cor\u201ds, or basic events (leaves). The following spellings are recognized as valid designations for event types: And: \u201cAnd\u201d \u201cand\u201d \u201cAND\u201d Or: \u201cOr\u201d \u201cor\u201d \u201cOR\u201d Basic: \u201cBasic\u201d \u201cbasic\u201d \u201cBASIC\u201d filename ( string , optional ) \u2013 A filename for the output not including a filename extension. The extension will specified by the format parameter. format ( string , optional ) \u2013 The file format of the graphic output. Note that bitmap formats (png, bmp, or jpeg) will not be as sharp as the default svg vector format and most particularly when magnified. Returns : cutsets \u2013 Returns a list of cutsets, where each is defined as a list of events. Return type : list of lists Simulations \u00b6 System Dynamics \u00b6 init_sd_model \u00b6 selib. init_sd_model ( start , stop , dt ) \u00b6 Instantiates a system dynamics model for simulation add_stock \u00b6 selib. add_stock ( name , initial , inflows = [] , outflows = [] ) \u00b6 Adds a stock to the model Parameters : name ( str ) \u2013 The name of the stock initial ( float ) \u2013 Initial value of stock at start of simulation inflows ( list of float ) \u2013 The names of the inflows to the stock outflows ( list of float ) \u2013 The names of the outflows to the stock add_flow \u00b6 selib. add_flow ( name , equation , inputs = [] ) \u00b6 Adds a flow to the model Parameters : name ( str ) \u2013 The name of the flow equation ( str ) \u2013 Equation for the flow using other named model variables inputs ( list ) \u2013 Optional list of variable input names used to draw model diagram add_auxiliary \u00b6 selib. add_auxiliary ( name , equation , inputs = [] ) \u00b6 Adds auxiliary equation or constant to the model Parameters : name ( str ) \u2013 The name of the auxiliary equation ( str ) \u2013 Equation for the auxiliary using other named model variables inputs ( list ) \u2013 Optional list of variable input names used to draw model diagram plot_graph \u00b6 selib. plot_graph ( * outputs ) \u00b6 displays matplotlib graph for each model variable Parameters : variables ( str or list ) \u2013 comma separated variable name(s) or lists of variable names to plot on single graphs Return type : matplotlib graph save_graph \u00b6 selib. save_graph ( * outputs , filename = 'graph.png' ) \u00b6 save graph to file Parameters : variables ( variable name or list of variable names to plot on graph ) \u2013 filename ( file name with format extension ) \u2013 run_model \u00b6 selib. run_model ( verbose = True ) \u00b6 Executes the current model Returns : If continuous, returns 1) Pandas dataframe containing run outputs for each variable each timestep and 2) model dictionary. If discrete, returns 1) network dictionary with run statistics and 2) entity run data set_logical_run_time \u00b6 selib. set_logical_run_time ( condition ) \u00b6 Enables a run time to be measured based on a logical condition for when the simulation should be run (like a while statement). The logical end time will be available from the \u2018get_logical_end_time()\u2019 function in lieu of the fixed end time for a simulation. get_logical_end_time \u00b6 selib. get_logical_end_time ( ) \u00b6 Returns the logical end time as specified in a previous \u2018set_logical_run_time()\u2019 function call, in lieu of the fixed end time for a simulation. Returns : logical_end_time \u2013 end time when the \u2018set_logical_run_time()\u2019\u2019 condition expires Return type : float draw_model_diagram \u00b6 selib. draw_model_diagram ( filename = None , format = 'svg' ) \u00b6 Draw a diagram of the current model. Parameters : filename ( string , optional ) \u2013 A filename for the output not including a filename extension. The extension will specified by the format parameter. format ( string , optional ) \u2013 The file format of the graphic output. Note that bitmap formats (png, bmp, or jpeg) will not be as sharp as the default svg vector format and most particularly when magnified. Returns : g \u2013 Save the graph source code to file, and open the rendered result in its default viewing application. se-lib calls the Graphviz API for this. Return type : graph object view Discrete Event \u00b6 init_de_model \u00b6 selib. init_de_model ( ) \u00b6 Instantiates a discrete event model for simulation add_source \u00b6 selib. add_source ( name , entity_name , num_entities , connections , interarrival_time ) \u00b6 Add a source node to a discrete event model to generate entities. Parameters : name ( string ) \u2013 A name for the source. entity_name ( string ) \u2013 A name for the type of entity being generated. num_entities ( integer ) \u2013 Number of entities to generated. connections ( dictionary ) \u2013 A dictionary of the node connections after the source. The node names are the keys and the values are the relative probabilities of traversing the connections. interarrival_time ( string ) \u2013 The time between entity arrrivals into the system. The string may enclose a constant, random function or logical expression to be evaluated. add_server \u00b6 selib. add_server ( name , connections , service_time , capacity = 1 ) \u00b6 Add a server to a discrete event model. Parameters : name ( string ) \u2013 A name for the server. connections ( dictionary ) \u2013 A dictionary of the node connections after the server. The node names are the keys and the values are the relative probabilities of traversing the connection. capacity ( integer ) \u2013 The number of resource usage slots in the server add_delay \u00b6 selib. add_delay ( name , connections , delay_time ) \u00b6 Add a delay to a discrete event model. Parameters : name ( string ) \u2013 A name for the delay. connections ( dictionary ) \u2013 A dictionary of the node connections after the delay. The node names are the keys and the values are the relative probabilities of traversing the connections. delay_time ( float ) \u2013 The time delay for entities to traverse. May be a constant or random function. add_terminate \u00b6 selib. add_terminate ( name ) \u00b6 Add a terminate node to a discrete event model for entities leaving the system. Parameters : name ( string ) \u2013 A name for the terminate. run_model \u00b6 selib. run_model ( verbose = True ) \u00b6 Executes the current model Returns : If continuous, returns 1) Pandas dataframe containing run outputs for each variable each timestep and 2) model dictionary. If discrete, returns 1) network dictionary with run statistics and 2) entity run data draw_model_diagram \u00b6 selib. draw_model_diagram ( filename = None , format = 'svg' ) \u00b6 Draw a diagram of the current model. Parameters : filename ( string , optional ) \u2013 A filename for the output not including a filename extension. The extension will specified by the format parameter. format ( string , optional ) \u2013 The file format of the graphic output. Note that bitmap formats (png, bmp, or jpeg) will not be as sharp as the default svg vector format and most particularly when magnified. Returns : g \u2013 Save the graph source code to file, and open the rendered result in its default viewing application. se-lib calls the Graphviz API for this. Return type : graph object view plot_histogram \u00b6 selib. plot_histogram ( data , filename = None , xlabel = 'Data' ) \u00b6 Plot a histogram for a dataset and optionally save to a file. Parameters : data ( list ) \u2013 A list of the data values filename ( string , optional ) \u2013 A name for the file xlabel ( string , optional ) \u2013 A label for the x-axis Return type : A Matplotlib histogram","title":"Function Reference"},{"location":"function_reference/#function-reference","text":"To use se-lib, first import it before using any functions: import selib These function definitions follow the convention whereby required input parameters are shown first, then optional parameters are shown with an equal sign indicating the default values. A graph here is a generic set of nodes representing system elements connected by edges shown as non-directed or directed lines.","title":"Function Reference"},{"location":"function_reference/#diagrams","text":"","title":"Diagrams"},{"location":"function_reference/#context_diagram","text":"selib. context_diagram ( system , external_systems , filename = None , format = 'svg' , engine = 'neato' ) \u00b6 Returns a context diagram. Parameters : system_name ( string ) \u2013 The name of the system to label the diagram. external_systems ( list of strings ) \u2013 Names of the external systems that interact with the system in a list. filename ( string , optional ) \u2013 A filename for the output not including a filename extension. The extension will specified by the format parameter. format ( string , optional ) \u2013 The file format of the graphic output. Note that bitmap formats (png, bmp, or jpeg) will not be as sharp as the default svg vector format and most particularly when magnified. Returns : g \u2013 Save the graph source code to file, and open the rendered result in its default viewing application. PyML calls the Graphviz API for this. Return type : graph object view","title":"context_diagram"},{"location":"function_reference/#critical_path_diagram","text":"selib. critical_path_diagram ( tasks , task_dependencies , filename = None , format = 'svg' ) \u00b6 Compute and draw the critical path between dependent tasks as the longest in duration from start to finish. Parameters : tasks ( list of tuples where each contains a task name and dictionary for duration time ) \u2013 A list of tuples where each one contains a task name and dictionary for its duration time (where keyword = \u201cDuration\u201d and value is a number). task_dependencies ( list of tuples ) \u2013 A list of tuples describing the dependency relationships between tasks. Each relationship is a tuple containing the predecessor task followed by its successor task. These must be the same named tasks in the task list input above. filename ( string , optional ) \u2013 A filename for the output not including a filename extension. The extension will specified by the format parameter. format ( string , optional ) \u2013 The file format of the graphic output. Note that bitmap formats (png, bmp, or jpeg) will not be as sharp as the default svg vector format and most particularly when magnified. Returns : g \u2013 The rendered graph for display. It will be automatically displayed in Jupyter Notebooks or IPython consoles. With other Python editors it can be displayed in the associated console by typing the returned graph name (e.g., call the function with an assignment such as critical_path = critical_path_diagram(...) and then type critical_path in the console). If a filename is optionally provided, the rendered graph will also be saved as a file in the specified format. PyML calls the Graphviz API for this. Return type : graph object view","title":"critical_path_diagram"},{"location":"function_reference/#design_structure_matrix","text":"selib. design_structure_matrix ( elements , element_dependencies , filename = None , format = 'svg' ) \u00b6 Draw a design structure matrix of system elements and their dependencies. Matrix elements may represent tasks (process activities), system parameters or attributes. Parameters : elements ( list of strings ) \u2013 Names of the matrix elements as the row and column headings in a list. element_dependencies ( list of tuples ) \u2013 A list of tuples describing the relationships between elements. Each relationship is a tuple containing the relationship input element, output element and optionally a custom label (or other object) to mark the relationship in the form (\u201cinput element\u201d, \u201coutput element\u201d, \u201crelationship label\u201d). The default marking denoting a relationship is an uppercase \u2018X\u2019, therefore, the shortened tuple relationship (\u201cinput element\u201d, \u201coutput element\u201d) is equivalent to (\u201cinput element\u201d, \u201coutput element\u201d, \u201cX\u201d). A custom label can be specified as html code for styling of the font type, font color, cell color, etc. Images and unicode characters can be inserted this way, or other html markup for lists, tables, etc. filename ( string , optional ) \u2013 A filename for the output not including a filename extension. The extension will specified by the format parameter. format ( string , optional ) \u2013 The file format of the graphic output. Note that bitmap formats (png, bmp, or jpeg) will not be as sharp as the default svg vector format and most particularly when magnified. Returns : g \u2013 The rendered graph for display. It will be automatically displayed in Jupyter Notebooks or IPython consoles. With other Python editors it can be displayed in the associated console by typing the returned graph name (e.g., call the function with an assignment such as dsm = design_structure_matrix(...) and then type dsm in the console). If a filename is optionally provided, the rendered graph will also be saved as a file in the specified format. PyML calls the Graphviz API for this. Return type : graph object view","title":"design_structure_matrix"},{"location":"function_reference/#fault_tree_diagram","text":"selib. fault_tree_diagram ( ft , filename = None , format = 'svg' ) \u00b6 Returns a fault tree diagram. Parameters : ft ( list of tuples ) \u2013 A list of the faults as a tree hierarchy. Each fault is defined in a tuple containing the fault name, type, and underlying faults (if any) in the form (\"fault name\", \"fault name\", list of fault branches) with the branches as a list in the form [\"branch 1 name\", \"branch 2 name\", ... \"branch n name\"] to identify the adjoining faults. All basic events will have a blank list [] since they are the bottom leaves in the tree. The top event must be in the first row, but all other events can be in any order. They may begrouped by their event paths or by hierarchical levels as convenient. Event types can be conditional \u201cand\u201ds, conditional \u201cor\u201ds, or basic events (leaves). The following spellings are recognized as valid designations for event types: And: \u201cAnd\u201d \u201cand\u201d \u201cAND\u201d Or: \u201cOr\u201d \u201cor\u201d \u201cOR\u201d Basic: \u201cBasic\u201d \u201cbasic\u201d \u201cBASIC\u201d filename ( string , optional ) \u2013 A filename for the output not including a filename extension. The extension will specified by the format parameter. format ( string , optional ) \u2013 The file format of the graphic output. Note that bitmap formats (png, bmp, or jpeg) will not be as sharp as the default svg vector format and most particularly when magnified. Returns : g \u2013 Save the graph source code to file, and open the rendered result in its default viewing application. PyML calls the Graphviz API for this. Return type : graph object view","title":"fault_tree_diagram"},{"location":"function_reference/#sequence_diagram","text":"selib. sequence_diagram ( system_name , actors , objects , actions , filename = None format = 'svg' ) \u00b6 Returns a sequence diagram. Parameters : system_name ( string ) \u2013 The name of the system to label the diagram. actors ( list of strings ) \u2013 Names of the outside actors that participate in the activity sequence in a list. objects ( list of strings ) \u2013 Names of the system objects that participate in the activity sequence in a list. actions ( list of tuples ) \u2013 A chronologically ordered list describing the sequence of actions to be drawn. Each action is a tuple containing the action source, target and action name (or data/control passed) in the form (\u201csource\u201d, \u201ctarget\u201d, \u201caction name\u201d) indicating a labeled horizontal arrow drawn between them. filename ( string , optional ) \u2013 A filename for the output not including a filename extension. The extension will specified by the format parameter. format ( string , optional ) \u2013 The file format of the graphic output. Note that bitmap formats (png, bmp, or jpeg) will not be as sharp as the default svg vector format and most particularly when magnified. Returns : g \u2013 Save the graph source code to file, and open the rendered result in its default viewing application. PyML calls the Graphviz API for this. Return type : graph object view ### use_case_diagram selib. use_case_diagram ( system_name , actors , use_cases , interactions , use_case_relationships , filename = None , format = 'svg' ) \u00b6 Draw a use case diagram. Parameters : system_name ( string ) \u2013 The name of the system to label the diagram. actors ( list of strings ) \u2013 Names of the outside actors that interact with the system in the use cases in a list. use_cases ( list of strings ) \u2013 Names of the use cases in a list. interactions ( list of tuples ) \u2013 A list of the interactions to be drawn between actors and use cases. Each interaction is a tuple containing an actor and use case in the form (\u201cactor name\u201d, \u201cuse case name\u201d) indicating an arrow drawn from the actor to the use case. Interactions are graph edges. use_case_relationships ( list of tuples , optional ) \u2013 A list of the relationships, or associations to be drawn between use cases. Each relationship is a tuple containing a use case pair and type relationship in the form (\u201cuse case 1\u201d, \u201cuse case 2\u201d, \u201crelationship\u201d) indicating an arrow drawn from the first to the second use case. Relationship types are \u201c<<include>>\u201d, \u201c<<extend>>\u201d and \u201cgeneralization\u201d. filename ( string , optional ) \u2013 A filename for the output not including a filename extension. The extension will specified by the format parameter. format ( string , optional ) \u2013 The file format of the graphic output. Note that bitmap formats (png, bmp, or jpeg) will not be as sharp as the default svg vector format and most particularly when magnified. Returns : g \u2013 Save the graph source code to file, and open the rendered result in its default viewing application. PyML calls the Graphviz API for this. Return type : graph object view","title":"sequence_diagram"},{"location":"function_reference/#wbs_diagram","text":"selib. wbs_diagram ( decompositions , filename = None , format = 'svg' , rankdir = 'TB' ) \u00b6 Draw a work breakdown structure as a tree hierarchy. Decompositions describe the parent-child relationships. Parameters : decompositions ( list of tuples ) \u2013 A list of tuples describing the work decomposition relationships. Each relationship is a tuple containing the parent element followed by the child element. filename ( string , optional ) \u2013 A filename for the output not including a filename extension. The extension will specified by the format parameter. format ( string , optional ) \u2013 The file format of the graphic output. Note that bitmap formats (png, bmp, or jpeg) will not be as sharp as the default svg vector format and most particularly when magnified. rankdir ( string , optional ) \u2013 The direction to display the tree from the parent node. The default rankdir='TB' denotes top to bottom for a vertical tree decomposition. It can diagrammed horizontally by providing rankdir=\u2019LR\u2019 to designate left to right. Returns : g \u2013 The rendered graph for display. It will be automatically displayed in Jupyter Notebooks or IPython consoles. With other Python editors it can be displayed in the associated console by typing the returned graph name (e.g., call the function with an assignment such as wbs = wbs_diagram(...) and then type wbs in the console). If a filename is optionally provided, the rendered graph will also be saved as a file in the specified format. PyML calls the Graphviz API for this. Return type : graph object view","title":"wbs_diagram"},{"location":"function_reference/#analyses","text":"","title":"Analyses"},{"location":"function_reference/#fault_tree_cutsets","text":"selib. fault_tree_cutsets ( fault_tree ) \u00b6 Returns a fault tree cutset. Parameters : ft ( list of tuples ) \u2013 A list of the faults as a tree hierarchy. Each fault is defined in a tuple containing the fault name, type, and underlying faults (if any) in the form (\"fault name\", \"fault name\", list of fault branches) with the branches as a list in the form [\"branch 1 name\", \"branch 2 name\", ... \"branch n name\"] to identify the adjoining faults. All basic events will have a blank list [] since they are the bottom leaves in the tree. The top event must be in the first row, but all other events can be in any order. They may begrouped by their event paths or by hierarchical levels as convenient. Event types can be conditional \u201cand\u201ds, conditional \u201cor\u201ds, or basic events (leaves). The following spellings are recognized as valid designations for event types: And: \u201cAnd\u201d \u201cand\u201d \u201cAND\u201d Or: \u201cOr\u201d \u201cor\u201d \u201cOR\u201d Basic: \u201cBasic\u201d \u201cbasic\u201d \u201cBASIC\u201d filename ( string , optional ) \u2013 A filename for the output not including a filename extension. The extension will specified by the format parameter. format ( string , optional ) \u2013 The file format of the graphic output. Note that bitmap formats (png, bmp, or jpeg) will not be as sharp as the default svg vector format and most particularly when magnified. Returns : cutsets \u2013 Returns a list of cutsets, where each is defined as a list of events. Return type : list of lists","title":"fault_tree_cutsets"},{"location":"function_reference/#simulations","text":"","title":"Simulations"},{"location":"function_reference/#system-dynamics","text":"","title":"System Dynamics"},{"location":"function_reference/#init_sd_model","text":"selib. init_sd_model ( start , stop , dt ) \u00b6 Instantiates a system dynamics model for simulation","title":"init_sd_model"},{"location":"function_reference/#add_stock","text":"selib. add_stock ( name , initial , inflows = [] , outflows = [] ) \u00b6 Adds a stock to the model Parameters : name ( str ) \u2013 The name of the stock initial ( float ) \u2013 Initial value of stock at start of simulation inflows ( list of float ) \u2013 The names of the inflows to the stock outflows ( list of float ) \u2013 The names of the outflows to the stock","title":"add_stock"},{"location":"function_reference/#add_flow","text":"selib. add_flow ( name , equation , inputs = [] ) \u00b6 Adds a flow to the model Parameters : name ( str ) \u2013 The name of the flow equation ( str ) \u2013 Equation for the flow using other named model variables inputs ( list ) \u2013 Optional list of variable input names used to draw model diagram","title":"add_flow"},{"location":"function_reference/#add_auxiliary","text":"selib. add_auxiliary ( name , equation , inputs = [] ) \u00b6 Adds auxiliary equation or constant to the model Parameters : name ( str ) \u2013 The name of the auxiliary equation ( str ) \u2013 Equation for the auxiliary using other named model variables inputs ( list ) \u2013 Optional list of variable input names used to draw model diagram","title":"add_auxiliary"},{"location":"function_reference/#plot_graph","text":"selib. plot_graph ( * outputs ) \u00b6 displays matplotlib graph for each model variable Parameters : variables ( str or list ) \u2013 comma separated variable name(s) or lists of variable names to plot on single graphs Return type : matplotlib graph","title":"plot_graph"},{"location":"function_reference/#save_graph","text":"selib. save_graph ( * outputs , filename = 'graph.png' ) \u00b6 save graph to file Parameters : variables ( variable name or list of variable names to plot on graph ) \u2013 filename ( file name with format extension ) \u2013","title":"save_graph"},{"location":"function_reference/#run_model","text":"selib. run_model ( verbose = True ) \u00b6 Executes the current model Returns : If continuous, returns 1) Pandas dataframe containing run outputs for each variable each timestep and 2) model dictionary. If discrete, returns 1) network dictionary with run statistics and 2) entity run data","title":"run_model"},{"location":"function_reference/#set_logical_run_time","text":"selib. set_logical_run_time ( condition ) \u00b6 Enables a run time to be measured based on a logical condition for when the simulation should be run (like a while statement). The logical end time will be available from the \u2018get_logical_end_time()\u2019 function in lieu of the fixed end time for a simulation.","title":"set_logical_run_time"},{"location":"function_reference/#get_logical_end_time","text":"selib. get_logical_end_time ( ) \u00b6 Returns the logical end time as specified in a previous \u2018set_logical_run_time()\u2019 function call, in lieu of the fixed end time for a simulation. Returns : logical_end_time \u2013 end time when the \u2018set_logical_run_time()\u2019\u2019 condition expires Return type : float","title":"get_logical_end_time"},{"location":"function_reference/#draw_model_diagram","text":"selib. draw_model_diagram ( filename = None , format = 'svg' ) \u00b6 Draw a diagram of the current model. Parameters : filename ( string , optional ) \u2013 A filename for the output not including a filename extension. The extension will specified by the format parameter. format ( string , optional ) \u2013 The file format of the graphic output. Note that bitmap formats (png, bmp, or jpeg) will not be as sharp as the default svg vector format and most particularly when magnified. Returns : g \u2013 Save the graph source code to file, and open the rendered result in its default viewing application. se-lib calls the Graphviz API for this. Return type : graph object view","title":"draw_model_diagram"},{"location":"function_reference/#discrete-event","text":"","title":"Discrete Event"},{"location":"function_reference/#init_de_model","text":"selib. init_de_model ( ) \u00b6 Instantiates a discrete event model for simulation","title":"init_de_model"},{"location":"function_reference/#add_source","text":"selib. add_source ( name , entity_name , num_entities , connections , interarrival_time ) \u00b6 Add a source node to a discrete event model to generate entities. Parameters : name ( string ) \u2013 A name for the source. entity_name ( string ) \u2013 A name for the type of entity being generated. num_entities ( integer ) \u2013 Number of entities to generated. connections ( dictionary ) \u2013 A dictionary of the node connections after the source. The node names are the keys and the values are the relative probabilities of traversing the connections. interarrival_time ( string ) \u2013 The time between entity arrrivals into the system. The string may enclose a constant, random function or logical expression to be evaluated.","title":"add_source"},{"location":"function_reference/#add_server","text":"selib. add_server ( name , connections , service_time , capacity = 1 ) \u00b6 Add a server to a discrete event model. Parameters : name ( string ) \u2013 A name for the server. connections ( dictionary ) \u2013 A dictionary of the node connections after the server. The node names are the keys and the values are the relative probabilities of traversing the connection. capacity ( integer ) \u2013 The number of resource usage slots in the server","title":"add_server"},{"location":"function_reference/#add_delay","text":"selib. add_delay ( name , connections , delay_time ) \u00b6 Add a delay to a discrete event model. Parameters : name ( string ) \u2013 A name for the delay. connections ( dictionary ) \u2013 A dictionary of the node connections after the delay. The node names are the keys and the values are the relative probabilities of traversing the connections. delay_time ( float ) \u2013 The time delay for entities to traverse. May be a constant or random function.","title":"add_delay"},{"location":"function_reference/#add_terminate","text":"selib. add_terminate ( name ) \u00b6 Add a terminate node to a discrete event model for entities leaving the system. Parameters : name ( string ) \u2013 A name for the terminate.","title":"add_terminate"},{"location":"function_reference/#run_model_1","text":"selib. run_model ( verbose = True ) \u00b6 Executes the current model Returns : If continuous, returns 1) Pandas dataframe containing run outputs for each variable each timestep and 2) model dictionary. If discrete, returns 1) network dictionary with run statistics and 2) entity run data","title":"run_model"},{"location":"function_reference/#draw_model_diagram_1","text":"selib. draw_model_diagram ( filename = None , format = 'svg' ) \u00b6 Draw a diagram of the current model. Parameters : filename ( string , optional ) \u2013 A filename for the output not including a filename extension. The extension will specified by the format parameter. format ( string , optional ) \u2013 The file format of the graphic output. Note that bitmap formats (png, bmp, or jpeg) will not be as sharp as the default svg vector format and most particularly when magnified. Returns : g \u2013 Save the graph source code to file, and open the rendered result in its default viewing application. se-lib calls the Graphviz API for this. Return type : graph object view","title":"draw_model_diagram"},{"location":"function_reference/#plot_histogram","text":"selib. plot_histogram ( data , filename = None , xlabel = 'Data' ) \u00b6 Plot a histogram for a dataset and optionally save to a file. Parameters : data ( list ) \u2013 A list of the data values filename ( string , optional ) \u2013 A name for the file xlabel ( string , optional ) \u2013 A label for the x-axis Return type : A Matplotlib histogram","title":"plot_histogram"},{"location":"index%20with%20definitions%20and%20citations/","text":"Home \u00b6 Introduction \u00b6 ::: {.meta title=\"Python Modeling Library (PyML)\" description=\"Python Modeling Library (PyML)\" keywords=\"python modeling library, PyML, system modeling, SysML, UML, python, systems modeling language, unified modeling language, systems engineering, requirements diagram, use case diagram, sequence diagram, context diagram, work breakdown structure, WBS, wbs diagram, critical path, critical path diagram, fault tree analysis, fault tree diagram, fault tree cutsets, system dynamics, simulation, continuous systems\"} ::: Welcome to the Python Modeling Library (PyML) for systems modeling, analysis, documentation and code generation. It includes the SysML and UML modeling languages with additional capabilities enabling advanced analysis with Python libraries and language features. PyML is built with Graphviz, Matplotlib, NetworkX, NumPy and SciPy using Python as glue code with all systems modeling. It\\'s fun to be powerful with Python. New Online Capability and Simulation The upcoming PyML v.20 can run online in a browser. Try it at the SysML Diagram Scratchpad . We are also adding system dynamics modeling and simulation capability. Preview some features online at System Dynamics Demonstrations . Inputs and Outputs \u00b6 The diagram below shows the primary inputs and outputs of PyML. This diagram was generated with PyML utilities. Current Features \u00b6 This early release of PyML contains library functions for the following: Activity diagrams Context diagram<context_diagram> Critical path network diagram<critical_path_diagram> Design Structure Matrix (DSM)<design_structure_matrix> Fault Tree Diagram<fault_tree_diagram> Fault Tree Cutset Analysis<fault_tree_cutsets> Latex and PDF document generation utilities Use case diagram<use_case_diagram> Sequence diagram<sequence_diagram> Work Breakdown Structure (WBS) diagram<wbs_diagram> Feedback \u00b6 We value your feedback. Tell us how we can make PyML, its documentation and this website more useful. Please send comments, suggestions and interest in supporting the development to info@pyml.fun . Citation references, like [CIT2002] . Note that citations may get rearranged, e.g., to the bottom of the \\\"page\\\". .. [CIT2002] A citation (as often used in journals). Definition lists: what : Definition lists associate a term with a definition. how : The term is a one-line phrase, and the definition is one or more paragraphs or body elements, indented relative to the term. Blank lines are not allowed between term and definition. link a term to def Sphinx link to a term in the glossary while showing different text reStructuredText<RST> glosssary ::: glossary Sphinx : Sphinx is a tool that makes it easy to create intelligent and beautiful documentation. It was originally created for the Python documentation, and it has excellent facilities for the documentation of software projects in a range of languages. RST : |RST| is an easy-to-read, what-you-see-is-what-you-get plain text markup syntax and parser system. It is useful for in-line program documentation (such as Python docstrings), for quickly creating simple web pages, and for standalone documents. |RST| is designed for extensibility for specific application domains. The |RST| parser is a component of Docutils. :::","title":"Home"},{"location":"index%20with%20definitions%20and%20citations/#home","text":"","title":"Home"},{"location":"index%20with%20definitions%20and%20citations/#introduction","text":"::: {.meta title=\"Python Modeling Library (PyML)\" description=\"Python Modeling Library (PyML)\" keywords=\"python modeling library, PyML, system modeling, SysML, UML, python, systems modeling language, unified modeling language, systems engineering, requirements diagram, use case diagram, sequence diagram, context diagram, work breakdown structure, WBS, wbs diagram, critical path, critical path diagram, fault tree analysis, fault tree diagram, fault tree cutsets, system dynamics, simulation, continuous systems\"} ::: Welcome to the Python Modeling Library (PyML) for systems modeling, analysis, documentation and code generation. It includes the SysML and UML modeling languages with additional capabilities enabling advanced analysis with Python libraries and language features. PyML is built with Graphviz, Matplotlib, NetworkX, NumPy and SciPy using Python as glue code with all systems modeling. It\\'s fun to be powerful with Python. New Online Capability and Simulation The upcoming PyML v.20 can run online in a browser. Try it at the SysML Diagram Scratchpad . We are also adding system dynamics modeling and simulation capability. Preview some features online at System Dynamics Demonstrations .","title":"Introduction"},{"location":"index%20with%20definitions%20and%20citations/#inputs-and-outputs","text":"The diagram below shows the primary inputs and outputs of PyML. This diagram was generated with PyML utilities.","title":"Inputs and Outputs"},{"location":"index%20with%20definitions%20and%20citations/#current-features","text":"This early release of PyML contains library functions for the following: Activity diagrams Context diagram<context_diagram> Critical path network diagram<critical_path_diagram> Design Structure Matrix (DSM)<design_structure_matrix> Fault Tree Diagram<fault_tree_diagram> Fault Tree Cutset Analysis<fault_tree_cutsets> Latex and PDF document generation utilities Use case diagram<use_case_diagram> Sequence diagram<sequence_diagram> Work Breakdown Structure (WBS) diagram<wbs_diagram>","title":"Current Features"},{"location":"index%20with%20definitions%20and%20citations/#feedback","text":"We value your feedback. Tell us how we can make PyML, its documentation and this website more useful. Please send comments, suggestions and interest in supporting the development to info@pyml.fun . Citation references, like [CIT2002] . Note that citations may get rearranged, e.g., to the bottom of the \\\"page\\\". .. [CIT2002] A citation (as often used in journals). Definition lists: what : Definition lists associate a term with a definition. how : The term is a one-line phrase, and the definition is one or more paragraphs or body elements, indented relative to the term. Blank lines are not allowed between term and definition. link a term to def Sphinx link to a term in the glossary while showing different text reStructuredText<RST> glosssary ::: glossary Sphinx : Sphinx is a tool that makes it easy to create intelligent and beautiful documentation. It was originally created for the Python documentation, and it has excellent facilities for the documentation of software projects in a range of languages. RST : |RST| is an easy-to-read, what-you-see-is-what-you-get plain text markup syntax and parser system. It is useful for in-line program documentation (such as Python docstrings), for quickly creating simple web pages, and for standalone documents. |RST| is designed for extensibility for specific application domains. The |RST| parser is a component of Docutils. :::","title":"Feedback"},{"location":"installation/","text":"Installation \u00b6 se-lib is available on PyPI and can be installed with pip install se-lib from a terminal, other command shell or Anaconda command shell. The current version is 0.26.6. For more help see Detailed Anaconda Installation instructions. Alternatively, download the library file from PyPI and copy it to your local development folder or elsewhere on your Python path. If you use the recommended Anaconda Python distribution it will come with all of the required packages below except for Graphviz and Pdflatex. These are required: Python version 3.8 and higher. Graphviz is required to generate diagrams. After installing Anaconda, use its Powershell Command Prompt and type conda install -c conda-forge python-graphviz . With other Python environments it can be installed with pip install graphviz . Also see graphviz download or graphviz on PyPI for additional instructions for different platforms. The numpy package is used for model analysis and plotting features. The matplotlib package is required to use the graphical functionality of se-lib. Pdflatex is required to compile latex files and generate pdfs. It can be installed for Python or comes with standard latex distributions. Note that diagrams can still be produced without graphviz installed locally by providing the generated dot markup text to online tools. Without pdflatex , the latex markup can be copied to other publishing tools such as Overleaf for refinement and/or pdf generation. Updating \u00b6 To update from a previous version use pip update se-lib , but to ensure the latest is actually installed use pip install se-lib==0.26.6 which may be necessary. The current version can be found via the __doc__ method: from selib import * print ( selib . __doc__ ) se-lib Version .42.0 On Replit.com \u00b6 Repls are available that are pre-installed with the latest se-lib baseline, other dependent packages and executables. These can be forked into a user account to develop new scripts. Any of these will work for this purpose: Discrete Event Simulation System Dynamics Simulation Another method is to custom install the packages and create the environment. In a new repl, under Tools select Packages and search for \"se-lib\". Install the latest version shown as below. Depending on which functions you want to use, you may also need to install graphviz, pysd, pandas, netCDF4 and simpy similarly. Diagrams \u00b6 In a custom installation, creation of diagrams will also require adding the 2 lines pkgs.graphviz and pkgs.xdg-utils to the hidden file \"replit.nix\" per below. It can be accessed by selecting \"Show Hidden Files\" in the Files menu. { pkgs }: { deps = [ pkgs.python310Full pkgs.replitPackages.prybar-python310 pkgs.replitPackages.stderred pkgs.graphviz pkgs.xdg-utils ]; Updating \u00b6 Updating on replit.com also uses the package installer to remove the current and re-install to the latest. To determine the current version use the same method __doc__ method as above, or look in the Packager file pyproject.toml for the highlighted line for se-lib. This will be the correct version vs. what the package remover may show on the next step. [tool.poetry] name = \"python-template\" version = \"0.1.0\" description = \"\" authors = [ \"Your Name <you@example.com>\" ] [tool.poetry.dependencies] python = \">=3.10.0,<3.11\" numpy = \"^1.22.2\" replit = \"^3.2.4\" Flask = \"^2.2.0\" urllib3 = \"^1.26.12\" graphviz = \"^0.20.1\" simpy = \"^4.0.1\" se-lib = \"0.26.4\" matplotlib = \"^3.7.1\" To update the library for an existing repl first remove it as below after searching for \"se-lib\" in the package installer. It will appear as below and may inaccurately show the current version. The pyproject.toml is correct. Choose to remove and it will take a few minutes. Then install the latest version using the same method for initial installation above. Detailed Anaconda Installation \u00b6 Anaconda is a widely used development environment for the Python and R programming languages. Anaconda is available for Windows, Mac, and Linux. To get started: Download Anaconda for your operating system Install Anaconda according to your specific OS directions Open Anaconda Create a Custom Environment The next few steps are optional. The use of a custom environment is not required. However, you may find it useful to not be working in your base (root) environment. If you are going to be regularly downloading new packages and creating back-ups you can revert to, a custom environment is highly recommended. Select environments Click create Environment Settings Name your environment Select Python Click create Depending on your computer, this may take anywhere from 10 seconds to a couple minutes. Install selib \u00b6 On the homescreen for your environment, install the Jupyter Notebook and Powershell Prompt apps. Other apps may be installed, but are not required for this tutorial. To install se-lib: * Launch Powershell Prompt * Run the following command: pip install se-lib To verify successfull installation: * Open a Jupyter Notebook * import selib and create a context diagram import selib as se # system model system_name = \"Python Integrator with selib\" external_actors = [ \"User\" , \"OS\" , \"Graphviz\" ] # create context diagram se . context_diagram ( system_name , external_actors , filename = \"selib_contest_diagram_offline\" ) If everything worked correctly, you should see something like the figure below: You can ignore the warnings. You may or may not get them when running the program. Another good test to run is a systems dynamics model. Note that we use from selib import * in this example. if we did not do this, we would have to put se. in front of each function below. from selib import * init_sd_model ( start = 0 , stop = 10 , dt = .1 ) add_stock ( \"level\" , 50 , inflows = [ \"rate\" ]) add_auxiliary ( \"time_constant\" , .5 ) add_auxiliary ( \"goal\" , 100 ) add_flow ( \"rate\" , \"(goal - level) / time_constant\" ) run_model () plot_graph ( 'level' ) If everything worked correctly, you should see something similar to the figure below.","title":"Installation"},{"location":"installation/#installation","text":"se-lib is available on PyPI and can be installed with pip install se-lib from a terminal, other command shell or Anaconda command shell. The current version is 0.26.6. For more help see Detailed Anaconda Installation instructions. Alternatively, download the library file from PyPI and copy it to your local development folder or elsewhere on your Python path. If you use the recommended Anaconda Python distribution it will come with all of the required packages below except for Graphviz and Pdflatex. These are required: Python version 3.8 and higher. Graphviz is required to generate diagrams. After installing Anaconda, use its Powershell Command Prompt and type conda install -c conda-forge python-graphviz . With other Python environments it can be installed with pip install graphviz . Also see graphviz download or graphviz on PyPI for additional instructions for different platforms. The numpy package is used for model analysis and plotting features. The matplotlib package is required to use the graphical functionality of se-lib. Pdflatex is required to compile latex files and generate pdfs. It can be installed for Python or comes with standard latex distributions. Note that diagrams can still be produced without graphviz installed locally by providing the generated dot markup text to online tools. Without pdflatex , the latex markup can be copied to other publishing tools such as Overleaf for refinement and/or pdf generation.","title":"Installation"},{"location":"installation/#updating","text":"To update from a previous version use pip update se-lib , but to ensure the latest is actually installed use pip install se-lib==0.26.6 which may be necessary. The current version can be found via the __doc__ method: from selib import * print ( selib . __doc__ ) se-lib Version .42.0","title":"Updating"},{"location":"installation/#on-replitcom","text":"Repls are available that are pre-installed with the latest se-lib baseline, other dependent packages and executables. These can be forked into a user account to develop new scripts. Any of these will work for this purpose: Discrete Event Simulation System Dynamics Simulation Another method is to custom install the packages and create the environment. In a new repl, under Tools select Packages and search for \"se-lib\". Install the latest version shown as below. Depending on which functions you want to use, you may also need to install graphviz, pysd, pandas, netCDF4 and simpy similarly.","title":"On Replit.com"},{"location":"installation/#diagrams","text":"In a custom installation, creation of diagrams will also require adding the 2 lines pkgs.graphviz and pkgs.xdg-utils to the hidden file \"replit.nix\" per below. It can be accessed by selecting \"Show Hidden Files\" in the Files menu. { pkgs }: { deps = [ pkgs.python310Full pkgs.replitPackages.prybar-python310 pkgs.replitPackages.stderred pkgs.graphviz pkgs.xdg-utils ];","title":"Diagrams"},{"location":"installation/#updating_1","text":"Updating on replit.com also uses the package installer to remove the current and re-install to the latest. To determine the current version use the same method __doc__ method as above, or look in the Packager file pyproject.toml for the highlighted line for se-lib. This will be the correct version vs. what the package remover may show on the next step. [tool.poetry] name = \"python-template\" version = \"0.1.0\" description = \"\" authors = [ \"Your Name <you@example.com>\" ] [tool.poetry.dependencies] python = \">=3.10.0,<3.11\" numpy = \"^1.22.2\" replit = \"^3.2.4\" Flask = \"^2.2.0\" urllib3 = \"^1.26.12\" graphviz = \"^0.20.1\" simpy = \"^4.0.1\" se-lib = \"0.26.4\" matplotlib = \"^3.7.1\" To update the library for an existing repl first remove it as below after searching for \"se-lib\" in the package installer. It will appear as below and may inaccurately show the current version. The pyproject.toml is correct. Choose to remove and it will take a few minutes. Then install the latest version using the same method for initial installation above.","title":"Updating"},{"location":"installation/#detailed-anaconda-installation","text":"Anaconda is a widely used development environment for the Python and R programming languages. Anaconda is available for Windows, Mac, and Linux. To get started: Download Anaconda for your operating system Install Anaconda according to your specific OS directions Open Anaconda Create a Custom Environment The next few steps are optional. The use of a custom environment is not required. However, you may find it useful to not be working in your base (root) environment. If you are going to be regularly downloading new packages and creating back-ups you can revert to, a custom environment is highly recommended. Select environments Click create Environment Settings Name your environment Select Python Click create Depending on your computer, this may take anywhere from 10 seconds to a couple minutes.","title":"Detailed Anaconda Installation"},{"location":"installation/#install-selib","text":"On the homescreen for your environment, install the Jupyter Notebook and Powershell Prompt apps. Other apps may be installed, but are not required for this tutorial. To install se-lib: * Launch Powershell Prompt * Run the following command: pip install se-lib To verify successfull installation: * Open a Jupyter Notebook * import selib and create a context diagram import selib as se # system model system_name = \"Python Integrator with selib\" external_actors = [ \"User\" , \"OS\" , \"Graphviz\" ] # create context diagram se . context_diagram ( system_name , external_actors , filename = \"selib_contest_diagram_offline\" ) If everything worked correctly, you should see something like the figure below: You can ignore the warnings. You may or may not get them when running the program. Another good test to run is a systems dynamics model. Note that we use from selib import * in this example. if we did not do this, we would have to put se. in front of each function below. from selib import * init_sd_model ( start = 0 , stop = 10 , dt = .1 ) add_stock ( \"level\" , 50 , inflows = [ \"rate\" ]) add_auxiliary ( \"time_constant\" , .5 ) add_auxiliary ( \"goal\" , 100 ) add_flow ( \"rate\" , \"(goal - level) / time_constant\" ) run_model () plot_graph ( 'level' ) If everything worked correctly, you should see something similar to the figure below.","title":"Install selib"},{"location":"introduction/","text":"Introduction \u00b6 Welcome to the Python Modeling Library (PyML) for systems modeling, analysis, documentation and code generation. It includes the SysML and UML modeling languages with additional capabilities enabling advanced analysis with Python libraries and language features. PyML is built with Graphviz, Matplotlib, NetworkX, NumPy and SciPy using Python as glue code with all systems modeling. It\\'s fun to be powerful with Python. New Online Capability and Simulation The upcoming PyML v.20 can run online in a browser. Try it at the SysML Diagram Scratchpad . We are also adding system dynamics modeling and simulation capability. Preview some features online at System Dynamics Demonstrations .","title":"Introduction"},{"location":"introduction/#introduction","text":"Welcome to the Python Modeling Library (PyML) for systems modeling, analysis, documentation and code generation. It includes the SysML and UML modeling languages with additional capabilities enabling advanced analysis with Python libraries and language features. PyML is built with Graphviz, Matplotlib, NetworkX, NumPy and SciPy using Python as glue code with all systems modeling. It\\'s fun to be powerful with Python. New Online Capability and Simulation The upcoming PyML v.20 can run online in a browser. Try it at the SysML Diagram Scratchpad . We are also adding system dynamics modeling and simulation capability. Preview some features online at System Dynamics Demonstrations .","title":"Introduction"},{"location":"logo_and_html_image_files/","text":"","title":"Logo and html image files"},{"location":"logo_and_html_image_files0/","text":"","title":"Logo and html image files0"},{"location":"master_doc/","text":"::: {.meta title=\"Python Modeling Library (PyML)\" description=\"Python Modeling Library (PyML)\" keywords=\"python modeling library, PyML, system modeling, SysML, UML, python, systems modeling language, unified modeling language, systems engineering, requirements diagram, use case diagram, sequence diagram, context diagram, work breakdown structure, WBS, wbs diagram, critical path, critical path diagram, fault tree analysis, fault tree diagram, fault tree cutsets, system dynamics, simulation\"} ::: ::: {.toctree maxdepth=\"-1\" hidden=\"\"} Home \\<index> installation function_reference examples Playground \\<http://se-lib.org/online/sysml.html> Tutorials \\<tutorials/sd_incose> ::: ::: only latex Indices and tables \u00b6 genindex modindex search :::","title":"Master doc"},{"location":"master_doc/#indices-and-tables","text":"genindex modindex search :::","title":"Indices and tables"},{"location":"tutorials/course_portal/","text":"San Diego INCOSE Tutorial: Course Portal Problem \u00b6 A school is building out a course portal where instructors can manage their courses. The minimal viable product for the course portal must have the following functionality: 1. There shall be two roles: Instructor and Student 1. Instructors and students shall both be able to post discussions 1. Instructors shall be able to create quizzes 1. Students shall be able to take quizzes 1. The system shall grade the quizzes 1. The system shall post grades to a gradebook accessible by the student and instructor Using se-lib, start building a model with the following diagrams: 1. Context Diagram 1. Use Case diagram 1. Requirements diagram 1. Work Breakdown Structure A Google Colaboratory notebook is also available for this problem set.","title":"Course portal"},{"location":"tutorials/course_portal/#san-diego-incose-tutorial-course-portal-problem","text":"A school is building out a course portal where instructors can manage their courses. The minimal viable product for the course portal must have the following functionality: 1. There shall be two roles: Instructor and Student 1. Instructors and students shall both be able to post discussions 1. Instructors shall be able to create quizzes 1. Students shall be able to take quizzes 1. The system shall grade the quizzes 1. The system shall post grades to a gradebook accessible by the student and instructor Using se-lib, start building a model with the following diagrams: 1. Context Diagram 1. Use Case diagram 1. Requirements diagram 1. Work Breakdown Structure A Google Colaboratory notebook is also available for this problem set.","title":"San Diego INCOSE Tutorial: Course Portal Problem"},{"location":"tutorials/sd_incose%20temp/","text":"Tutorial \u00b6 San Diego INCOSE Tutorial: Open Source Systems Modeling Introduction \u00b6 The tutorial will cover new open-source system modeling capabilities, and immediately enable participants to implement them requiring only an Internet connection. The Systems Engineering Library ( se-lib ) using Python is described at http://se-lib.org and can be used online or installed for offline usage. se-lib lowers barriers to system modeling with an open-source tool environment harnessing the extensive Python scientific computing ecosystem. It provides integrated capabilities for system modeling, analysis, and automatic documentation with SysML, other SE model types and analysis methods. The environment enables natural integration of models, inline or external data with only a few lines of code. Numerous examples, templates, and modeling case studies will be provided. Students only need basic computer skills to modify the examples or create new models. Previous knowledge of Python isn\u2019t necessary. Examples are self-evident since Python is highly readable and concise, so exercises will be based around simple short code. With se-lib participants will learn how to incorporate open source modeling in system engineering processes and toolsets. They will understand how open source tools can support rapid iterative processes and automate round-trip digital engineering when reconciling single-source truth models. Participants will require a laptop or other device (tablet or phone would work) and an Internet connection (unless they install the library prior and prefer to work offline). They will rapidly model, analyze, and automatically document systems with naturally integrated models. Prerequisites \u00b6 General knowledge of system modeling methods as exemplified by SysML, other model types, systems engineering analysis and simulation. Exposure to computer programming from traditional engineering degree or on the job is helpful. Agenda \u00b6 Overview of se-lib usage and architecture as demonstrated with system models generated by se-lib . (20 minutes) Brief introduction to Python syntax by inspection of model examples. Hands-on introduction (30 minutes) se-lib online library installation Google Colaboratory . Open in Colab to run or save your own copy in Drive\" Anaconda Model library demonstrations and exercises SysML modeling and diagrams System dynamics continuous modeling and simulation Discrete event modeling and simulation Fault tree analysis, diagrams, and system reliability modeling Project management modeling Integration of models Automatic document re-generation with reconciled changes across model sets Model data import/export and sharing with other tools. Further examples, guided exercises, and extended case studies on above areas for integrated system modeling. Students will be given options for exercises based on their interests and the opportunity to focus on their own system models. If students do not have a particular problem, they would like to focus on, a sample course portal problem is available. Lunch Advanced usage with Python scientific computing ecosystem and open source communities Introduce libraries that are building blocks of se-lib, how they interface with and depend on each other, how to navigate and leverage their capabilities for system modeling applications. Matplotlib Pandas SciPy Digital engineering and rapid change: automated model configuration management, re-execution, impact analysis and version control for round-trip digital engineering. Demonstrate how all model artifacts in text files are managed with standard automated tools (e.g. GitHub for small to large teams). Collaborative Modeling of Target Shooter System Future capabilities and evolution plans Audience will provide input on desired features and changes Presenters \u00b6 Ray Madachy Raymond Madachy, Ph.D., is a Professor in the Systems Engineering Department at the Naval Postgraduate School. His research interests include system and software cost modeling; affordability and tradespace analysis; modeling and simulation of systems and software engineering processes; integrating systems engineering and software engineering disciplines; and systems engineering tool environments. His research has been funded by diverse agencies across the DoD, National Security Agency, NASA, and several companies. He has developed widely used tools for systems and software cost estimation, and is leading development of the open-source Systems Engineering Library (se-lib). He received the USC Center for Systems and Software Engineering Lifetime Achievement Award for \u201cInnovative Development of a Wide Variety of Cost, Schedule and Quality Models and Simulations\u201d in 2016. His books include Software Process Dynamics, What Every Engineer Should Know about Modeling and Simulation; co-author of Software Cost Estimation with COCOMO II, and Software Cost Estimation Metrics Manual for Defense Systems. He is writing Systems Engineering Principles for Software Engineers and What Every Engineer Should Know about Python. Ryan Longshore Ryan Longshore is an 18 year veteran of both the defense and electric utility industries. In his current role at Naval Information Warfare Center Atlantic (NIWC LANT), Ryan leads a diverse team of engineers and scientists developing and integrating new technologies into command and operations centers. Ryan is heavily involved in the Navy's digital engineering transformation and leads multiple efforts in the model based systems engineering and model based engineering realms. Ryan earned a BS in Electrical Engineering from Clemson University, a MS in Systems Engineering from Southern Methodist University, and is currently pursuing his PhD in Systems Engineering from the Naval Postrgraduate School. He is a South Carolina registered Professional Engineer (PE), an INCOSE Certified Systems Engineering Professional (CSEP), and has achieved the OMG SysML Model Builder Fundamental Certification.","title":"Tutorial"},{"location":"tutorials/sd_incose%20temp/#tutorial","text":"San Diego INCOSE Tutorial: Open Source Systems Modeling","title":"Tutorial"},{"location":"tutorials/sd_incose%20temp/#introduction","text":"The tutorial will cover new open-source system modeling capabilities, and immediately enable participants to implement them requiring only an Internet connection. The Systems Engineering Library ( se-lib ) using Python is described at http://se-lib.org and can be used online or installed for offline usage. se-lib lowers barriers to system modeling with an open-source tool environment harnessing the extensive Python scientific computing ecosystem. It provides integrated capabilities for system modeling, analysis, and automatic documentation with SysML, other SE model types and analysis methods. The environment enables natural integration of models, inline or external data with only a few lines of code. Numerous examples, templates, and modeling case studies will be provided. Students only need basic computer skills to modify the examples or create new models. Previous knowledge of Python isn\u2019t necessary. Examples are self-evident since Python is highly readable and concise, so exercises will be based around simple short code. With se-lib participants will learn how to incorporate open source modeling in system engineering processes and toolsets. They will understand how open source tools can support rapid iterative processes and automate round-trip digital engineering when reconciling single-source truth models. Participants will require a laptop or other device (tablet or phone would work) and an Internet connection (unless they install the library prior and prefer to work offline). They will rapidly model, analyze, and automatically document systems with naturally integrated models.","title":"Introduction"},{"location":"tutorials/sd_incose%20temp/#prerequisites","text":"General knowledge of system modeling methods as exemplified by SysML, other model types, systems engineering analysis and simulation. Exposure to computer programming from traditional engineering degree or on the job is helpful.","title":"Prerequisites"},{"location":"tutorials/sd_incose%20temp/#agenda","text":"Overview of se-lib usage and architecture as demonstrated with system models generated by se-lib . (20 minutes) Brief introduction to Python syntax by inspection of model examples. Hands-on introduction (30 minutes) se-lib online library installation Google Colaboratory . Open in Colab to run or save your own copy in Drive\" Anaconda Model library demonstrations and exercises SysML modeling and diagrams System dynamics continuous modeling and simulation Discrete event modeling and simulation Fault tree analysis, diagrams, and system reliability modeling Project management modeling Integration of models Automatic document re-generation with reconciled changes across model sets Model data import/export and sharing with other tools. Further examples, guided exercises, and extended case studies on above areas for integrated system modeling. Students will be given options for exercises based on their interests and the opportunity to focus on their own system models. If students do not have a particular problem, they would like to focus on, a sample course portal problem is available. Lunch Advanced usage with Python scientific computing ecosystem and open source communities Introduce libraries that are building blocks of se-lib, how they interface with and depend on each other, how to navigate and leverage their capabilities for system modeling applications. Matplotlib Pandas SciPy Digital engineering and rapid change: automated model configuration management, re-execution, impact analysis and version control for round-trip digital engineering. Demonstrate how all model artifacts in text files are managed with standard automated tools (e.g. GitHub for small to large teams). Collaborative Modeling of Target Shooter System Future capabilities and evolution plans Audience will provide input on desired features and changes","title":"Agenda"},{"location":"tutorials/sd_incose%20temp/#presenters","text":"Ray Madachy Raymond Madachy, Ph.D., is a Professor in the Systems Engineering Department at the Naval Postgraduate School. His research interests include system and software cost modeling; affordability and tradespace analysis; modeling and simulation of systems and software engineering processes; integrating systems engineering and software engineering disciplines; and systems engineering tool environments. His research has been funded by diverse agencies across the DoD, National Security Agency, NASA, and several companies. He has developed widely used tools for systems and software cost estimation, and is leading development of the open-source Systems Engineering Library (se-lib). He received the USC Center for Systems and Software Engineering Lifetime Achievement Award for \u201cInnovative Development of a Wide Variety of Cost, Schedule and Quality Models and Simulations\u201d in 2016. His books include Software Process Dynamics, What Every Engineer Should Know about Modeling and Simulation; co-author of Software Cost Estimation with COCOMO II, and Software Cost Estimation Metrics Manual for Defense Systems. He is writing Systems Engineering Principles for Software Engineers and What Every Engineer Should Know about Python. Ryan Longshore Ryan Longshore is an 18 year veteran of both the defense and electric utility industries. In his current role at Naval Information Warfare Center Atlantic (NIWC LANT), Ryan leads a diverse team of engineers and scientists developing and integrating new technologies into command and operations centers. Ryan is heavily involved in the Navy's digital engineering transformation and leads multiple efforts in the model based systems engineering and model based engineering realms. Ryan earned a BS in Electrical Engineering from Clemson University, a MS in Systems Engineering from Southern Methodist University, and is currently pursuing his PhD in Systems Engineering from the Naval Postrgraduate School. He is a South Carolina registered Professional Engineer (PE), an INCOSE Certified Systems Engineering Professional (CSEP), and has achieved the OMG SysML Model Builder Fundamental Certification.","title":"Presenters"},{"location":"tutorials/sd_incose/","text":"Tutorials \u00b6 San Diego INCOSE Tutorial: Open Source Systems Modeling Zoom Link Passcode: CvaFqM0s$M The tutorial will cover new open-source system modeling capabilities, and immediately enable participants to implement them requiring only an Internet connection. The Systems Engineering Library ( se-lib ) using Python is described at http://se-lib.org and can be used online or installed for offline usage. se-lib lowers barriers to system modeling with an open-source tool environment harnessing the extensive Python scientific computing ecosystem. It provides integrated capabilities for system modeling, analysis, and automatic documentation with SysML, other SE model types and analysis methods. The environment enables natural integration of models, inline or external data with only a few lines of code. Numerous examples, templates, and modeling case studies will be provided. Students only need basic computer skills to modify the examples or create new models. Previous knowledge of Python isn\u2019t necessary. Examples are self-evident since Python is highly readable and concise, so exercises will be based around simple short code. With se-lib participants will learn how to incorporate open source modeling in system engineering processes and toolsets. They will understand how open source tools can support rapid iterative processes and automate round-trip digital engineering when reconciling single-source truth models. Participants will require a laptop or other device (tablet or phone would work) and an Internet connection (unless they install the library prior and prefer to work offline). They will rapidly model, analyze, and automatically document systems with naturally integrated models. Prerequisites \u00b6 General knowledge of system modeling methods as exemplified by SysML, other model types, systems engineering analysis and simulation. Exposure to computer programming from traditional engineering degree or on the job is helpful. Agenda \u00b6 0900 - 0915 (Madachy): Welcome and Introductions 0915 - 0935 (Madachy): Overview of se-lib Usage and architecture Brief introduction to Python syntax Website resources 0935 - 1000 (Longshore): Hands-on introduction se-lib playground library installation Google Colaboratory . Open in Colab to run or save your own copy in Google Drive Replit Anaconda 1000 - 1010: Break 1010 - 1130: Model library demonstrations and exercises (Longshore) SysML modeling and diagrams (Madachy) Simulation System Dynamics Modeling with se-lib User's Guide v. 1.0 System dynamics simulation on Google Colab Discrete event modeling and simulation on se-lib playground (Longshore) Fault tree analysis, diagrams, and system reliability modeling (Longshore) Project management modeling (Madachy/Longshore) Model data import/export and sharing with other tools. Excel xmile format, Vensim, iThink 1130 - 1200 (Madachy/Longshore): Further examples, guided exercises, and extended case studies on above areas for integrated system modeling. Students will be given options for exercises based on their interests and the opportunity to focus on their own system models. If students do not have a particular problem to focus on, here are some samples: course portal problem simulation exercises 1200 - 1300: Lunch 1300 - 1330: Advanced usage with Python scientific computing ecosystem and open source communities (Madachy) Introduce libraries that are building blocks of se-lib, how they interface with and depend on each other, how to navigate and leverage their capabilities for system modeling applications. (Madachy) Matplotlib (Longshore) Pandas (Longshore) SciPy 1330 - 1345 (Madachy / Longshore): Digital engineering and rapid change: automated model configuration management, re-execution, impact analysis and version control for round-trip digital engineering. Demonstrate how all model artifacts in text files are managed with standard automated tools (e.g. GitHub for small to large teams). Collaborative modeling of Target Shooter System GitHub document and source code management team processes 1345 - 1430: Future capabilities and evolution plans (Workshop Format) Audience will provide input on desired features and changes Written summary and wrapup Presenters \u00b6 Ray Madachy Raymond Madachy, Ph.D., is a Professor in the Systems Engineering Department at the Naval Postgraduate School. His research interests include system and software cost modeling; affordability and tradespace analysis; modeling and simulation of systems and software engineering processes; integrating systems engineering and software engineering disciplines; and systems engineering tool environments. His research has been funded by diverse agencies across the DoD, National Security Agency, NASA, and several companies. He has developed widely used tools for systems and software cost estimation, and is leading development of the open-source Systems Engineering Library (se-lib). He received the USC Center for Systems and Software Engineering Lifetime Achievement Award for \u201cInnovative Development of a Wide Variety of Cost, Schedule and Quality Models and Simulations\u201d in 2016. His books include Software Process Dynamics, What Every Engineer Should Know about Modeling and Simulation; co-author of Software Cost Estimation with COCOMO II, and Software Cost Estimation Metrics Manual for Defense Systems. He is writing Systems Engineering Principles for Software Engineers and What Every Engineer Should Know about Python. Ryan Longshore Ryan Longshore is an 18 year veteran of both the defense and electric utility industries. In his current role at Naval Information Warfare Center Atlantic (NIWC LANT), Ryan leads a diverse team of engineers and scientists developing and integrating new technologies into command and operations centers. Ryan is heavily involved in the Navy's digital engineering transformation and leads multiple efforts in the model based systems engineering and model based engineering realms. Ryan earned a BS in Electrical Engineering from Clemson University, a MS in Systems Engineering from Southern Methodist University, and is currently pursuing his PhD in Systems Engineering from the Naval Postrgraduate School. He is a South Carolina registered Professional Engineer (PE), an INCOSE Certified Systems Engineering Professional (CSEP), and has achieved the OMG SysML Model Builder Fundamental Certification. Participants \u00b6 Greg Bulla Vanessa Cannon Frank Camp Alexandro Castaneda Brian Flick Cheryl Gray Juan Hernandez Guizar Arianna Lasche Ariel Lu Marilyn Luteman Curran Meek Gregg Morissette Ted Mulder Kenneth Sakaguchi James Sanford-Luevano Dr. Julia Taylor John Thomas Ted Valencia Earl Zedd","title":"Tutorials"},{"location":"tutorials/sd_incose/#tutorials","text":"San Diego INCOSE Tutorial: Open Source Systems Modeling Zoom Link Passcode: CvaFqM0s$M The tutorial will cover new open-source system modeling capabilities, and immediately enable participants to implement them requiring only an Internet connection. The Systems Engineering Library ( se-lib ) using Python is described at http://se-lib.org and can be used online or installed for offline usage. se-lib lowers barriers to system modeling with an open-source tool environment harnessing the extensive Python scientific computing ecosystem. It provides integrated capabilities for system modeling, analysis, and automatic documentation with SysML, other SE model types and analysis methods. The environment enables natural integration of models, inline or external data with only a few lines of code. Numerous examples, templates, and modeling case studies will be provided. Students only need basic computer skills to modify the examples or create new models. Previous knowledge of Python isn\u2019t necessary. Examples are self-evident since Python is highly readable and concise, so exercises will be based around simple short code. With se-lib participants will learn how to incorporate open source modeling in system engineering processes and toolsets. They will understand how open source tools can support rapid iterative processes and automate round-trip digital engineering when reconciling single-source truth models. Participants will require a laptop or other device (tablet or phone would work) and an Internet connection (unless they install the library prior and prefer to work offline). They will rapidly model, analyze, and automatically document systems with naturally integrated models.","title":"Tutorials"},{"location":"tutorials/sd_incose/#prerequisites","text":"General knowledge of system modeling methods as exemplified by SysML, other model types, systems engineering analysis and simulation. Exposure to computer programming from traditional engineering degree or on the job is helpful.","title":"Prerequisites"},{"location":"tutorials/sd_incose/#agenda","text":"0900 - 0915 (Madachy): Welcome and Introductions 0915 - 0935 (Madachy): Overview of se-lib Usage and architecture Brief introduction to Python syntax Website resources 0935 - 1000 (Longshore): Hands-on introduction se-lib playground library installation Google Colaboratory . Open in Colab to run or save your own copy in Google Drive Replit Anaconda 1000 - 1010: Break 1010 - 1130: Model library demonstrations and exercises (Longshore) SysML modeling and diagrams (Madachy) Simulation System Dynamics Modeling with se-lib User's Guide v. 1.0 System dynamics simulation on Google Colab Discrete event modeling and simulation on se-lib playground (Longshore) Fault tree analysis, diagrams, and system reliability modeling (Longshore) Project management modeling (Madachy/Longshore) Model data import/export and sharing with other tools. Excel xmile format, Vensim, iThink 1130 - 1200 (Madachy/Longshore): Further examples, guided exercises, and extended case studies on above areas for integrated system modeling. Students will be given options for exercises based on their interests and the opportunity to focus on their own system models. If students do not have a particular problem to focus on, here are some samples: course portal problem simulation exercises 1200 - 1300: Lunch 1300 - 1330: Advanced usage with Python scientific computing ecosystem and open source communities (Madachy) Introduce libraries that are building blocks of se-lib, how they interface with and depend on each other, how to navigate and leverage their capabilities for system modeling applications. (Madachy) Matplotlib (Longshore) Pandas (Longshore) SciPy 1330 - 1345 (Madachy / Longshore): Digital engineering and rapid change: automated model configuration management, re-execution, impact analysis and version control for round-trip digital engineering. Demonstrate how all model artifacts in text files are managed with standard automated tools (e.g. GitHub for small to large teams). Collaborative modeling of Target Shooter System GitHub document and source code management team processes 1345 - 1430: Future capabilities and evolution plans (Workshop Format) Audience will provide input on desired features and changes Written summary and wrapup","title":"Agenda"},{"location":"tutorials/sd_incose/#presenters","text":"Ray Madachy Raymond Madachy, Ph.D., is a Professor in the Systems Engineering Department at the Naval Postgraduate School. His research interests include system and software cost modeling; affordability and tradespace analysis; modeling and simulation of systems and software engineering processes; integrating systems engineering and software engineering disciplines; and systems engineering tool environments. His research has been funded by diverse agencies across the DoD, National Security Agency, NASA, and several companies. He has developed widely used tools for systems and software cost estimation, and is leading development of the open-source Systems Engineering Library (se-lib). He received the USC Center for Systems and Software Engineering Lifetime Achievement Award for \u201cInnovative Development of a Wide Variety of Cost, Schedule and Quality Models and Simulations\u201d in 2016. His books include Software Process Dynamics, What Every Engineer Should Know about Modeling and Simulation; co-author of Software Cost Estimation with COCOMO II, and Software Cost Estimation Metrics Manual for Defense Systems. He is writing Systems Engineering Principles for Software Engineers and What Every Engineer Should Know about Python. Ryan Longshore Ryan Longshore is an 18 year veteran of both the defense and electric utility industries. In his current role at Naval Information Warfare Center Atlantic (NIWC LANT), Ryan leads a diverse team of engineers and scientists developing and integrating new technologies into command and operations centers. Ryan is heavily involved in the Navy's digital engineering transformation and leads multiple efforts in the model based systems engineering and model based engineering realms. Ryan earned a BS in Electrical Engineering from Clemson University, a MS in Systems Engineering from Southern Methodist University, and is currently pursuing his PhD in Systems Engineering from the Naval Postrgraduate School. He is a South Carolina registered Professional Engineer (PE), an INCOSE Certified Systems Engineering Professional (CSEP), and has achieved the OMG SysML Model Builder Fundamental Certification.","title":"Presenters"},{"location":"tutorials/sd_incose/#participants","text":"Greg Bulla Vanessa Cannon Frank Camp Alexandro Castaneda Brian Flick Cheryl Gray Juan Hernandez Guizar Arianna Lasche Ariel Lu Marilyn Luteman Curran Meek Gregg Morissette Ted Mulder Kenneth Sakaguchi James Sanford-Luevano Dr. Julia Taylor John Thomas Ted Valencia Earl Zedd","title":"Participants"},{"location":"tutorials/simulation_exercises/","text":"Simulation exercises \u00b6 Discrete Event \u00b6 Target Shooter System \u00b6 Include the detection subsystem by extending the model structure and re-run simulation experiments. Create a new delay node for the detection with a random detection time. Its delay will be included in the overall response time. Vary its random characteristics and observe the resulting response time behavior. NumPy Distributions You can use the following functions after import numpy as np : np.random.random() The function does not take any arguments and returns a random value between 0 and 1. np.random.uniform(min, max) The function takes two arguments, which are the minimum and maximum values of the distribution. np.random.triangle(min, mode, max) The function takes three arguments, which are the minimum, mode, and maximum values of the distribution. np.random.exponential(rate) The function takes one argument, which is the rate parameter of the distribution. Security Gate Operations \u00b6 Modify the target shooter system, electric car charging system, or create a new model for security gate operations. Vary the number of attendant guards as \"capacity\" and observe changes in the waiting times. First simulate cars coming at a constant interarrival rates and gate service times. Next simulate cars coming at a uniformly distributed interarrival rate. Calibrate the incoming rate to actual traffic levels. Include an additional entry gate and vary the incoming traffic patterns across both. Electric Car Charging Model \u00b6 Modify the incoming traffic arrival pattern. Add another source of incoming cars. First simulate cars coming at a constant interarrival rates and gate service times. Next simulate cars coming at a uniformly distributed interarrival rate. Calibrate the incoming rate to actual traffic levels. System Dynamics \u00b6 Modify some examples in the notebook se-lib system dynamics examples . Change parameters Change model structure Add more variable plots Workforce Model \u00b6 Develop a workforce model with an incoming hiring rate, a stock for the current level of workforce level, and an attrition outflow. Use a first order delay with an average delay time for the hiring rate. Law System Modeling \u00b6 Create a simple predator-prey model of criminal behavior to help evaluate enforcement and sanction policies.","title":"Simulation exercises"},{"location":"tutorials/simulation_exercises/#simulation-exercises","text":"","title":"Simulation exercises"},{"location":"tutorials/simulation_exercises/#discrete-event","text":"","title":"Discrete Event"},{"location":"tutorials/simulation_exercises/#target-shooter-system","text":"Include the detection subsystem by extending the model structure and re-run simulation experiments. Create a new delay node for the detection with a random detection time. Its delay will be included in the overall response time. Vary its random characteristics and observe the resulting response time behavior. NumPy Distributions You can use the following functions after import numpy as np : np.random.random() The function does not take any arguments and returns a random value between 0 and 1. np.random.uniform(min, max) The function takes two arguments, which are the minimum and maximum values of the distribution. np.random.triangle(min, mode, max) The function takes three arguments, which are the minimum, mode, and maximum values of the distribution. np.random.exponential(rate) The function takes one argument, which is the rate parameter of the distribution.","title":"Target Shooter System"},{"location":"tutorials/simulation_exercises/#security-gate-operations","text":"Modify the target shooter system, electric car charging system, or create a new model for security gate operations. Vary the number of attendant guards as \"capacity\" and observe changes in the waiting times. First simulate cars coming at a constant interarrival rates and gate service times. Next simulate cars coming at a uniformly distributed interarrival rate. Calibrate the incoming rate to actual traffic levels. Include an additional entry gate and vary the incoming traffic patterns across both.","title":"Security Gate Operations"},{"location":"tutorials/simulation_exercises/#electric-car-charging-model","text":"Modify the incoming traffic arrival pattern. Add another source of incoming cars. First simulate cars coming at a constant interarrival rates and gate service times. Next simulate cars coming at a uniformly distributed interarrival rate. Calibrate the incoming rate to actual traffic levels.","title":"Electric Car Charging Model"},{"location":"tutorials/simulation_exercises/#system-dynamics","text":"Modify some examples in the notebook se-lib system dynamics examples . Change parameters Change model structure Add more variable plots","title":"System Dynamics"},{"location":"tutorials/simulation_exercises/#workforce-model","text":"Develop a workforce model with an incoming hiring rate, a stock for the current level of workforce level, and an attrition outflow. Use a first order delay with an average delay time for the hiring rate.","title":"Workforce Model"},{"location":"tutorials/simulation_exercises/#law-system-modeling","text":"Create a simple predator-prey model of criminal behavior to help evaluate enforcement and sanction policies.","title":"Law System Modeling"}]}